---
title: "Coexistence with varying environmental filtering intensity"
author: "XX"
date: "5 juin 2018"
output: pdf_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(cowplot)
library(dplyr)
library(FD)
```

# Single trait

```{r}
devtools::load_all()
#### Keep stable for all
patches  <- 25   # Number of patches
species  <- 25   # Number of species
time     <- 150	 # Length of model run (generations)
initpop  <- 50   # initial population size
n_traits <- 1    # number of traits
k        <- 1.45 # Niche height
width    <- seq(10, 0.25, length.out = patches) # Niche breadth

# Competition + Dispersion coefficients
A =  0.0005	# Alpha scalar 
d = 0.0#5 # Dispersal percentage

# Generate environment
env <- 1:patches

composition <- array(NA, dim = c(patches, species, time),
                     dimnames = list(paste0("patches", 1:patches),
                                     paste0("species", 1:species),
                                     paste0("time", 1:time))) #where values = N
names(env) <- dimnames(composition)[[1]]

composition[,,"time1"] <- initpop # N

# Generate traits
traits <- generate_traits(species,
                          rep(min(env), n_traits),
                          rep(max(env), n_traits))

# Single trait competition, single trait growth, single trait both -------------
# Goal: compare between the three above-mentioned cases

## Single Trait Competition
trait_type = c(trait1 = "A")
single_trait_compet = multigen(traits = traits, trait_type = trait_type,
                               env = env, time = time, species = species,
                               patches = patches, composition = composition,
                               A = A, d = d, k = k, width = width)
single_trait_compet_final = ifelse(single_trait_compet$compo[,,time] < 2, 0, single_trait_compet$compo[,,time])

## Single Trait Growth
trait_type = c(trait1 = "R")
single_trait_growth = multigen(traits = traits, trait_type = trait_type,
                               env = env, time = time, species = species,
                               patches = patches, composition = composition,
                               A = A, d = d, k = k, width = width)
single_trait_growth_final = ifelse(single_trait_growth$compo[,,time] < 2, 0,
                                   single_trait_growth$compo[,,time])

## Both
trait_type = c(trait1 = "RA")
single_trait_both = multigen(traits = traits, trait_type = trait_type,
                             env = env, time = time, species = species,
                             patches = patches, composition = composition,
                             A = A, d = d, k = k, width = width)

single_trait_both_final = ifelse(single_trait_both$compo[,,time] < 2, 0,
                                 single_trait_both$compo[,,time])

```

```{r}
p5_comp = plot_patch(single_trait_compet$compo, 5, 150) +
    labs(subtitle = "Competition")
p5_grow = plot_patch(single_trait_growth$compo, 5, 150) +
    labs(subtitle = "Growth")
p5_both = plot_patch(single_trait_both$compo,   5, 150) +
    labs(subtitle = "Both")

p15_comp = plot_patch(single_trait_compet$compo, 15, 150) +
    labs(subtitle = "Competition")
p15_grow = plot_patch(single_trait_growth$compo, 15, 150)  +
    labs(subtitle = "Growth")
p15_both = plot_patch(single_trait_both$compo,   15, 150) +
    labs(subtitle = "Both")

plot_patches = plot_grid(p5_grow, p5_comp, p5_both, p15_grow, p15_comp,
                         p15_both, ncol = 3, nrow = 2)
plot_patches
```

## Compute CWM & CWV

```{r}
compute_moments = function(simulation_routine, trait_df = traits) {
    # CWM computation
    ab_rel = (simulation_routine$compo[,,150] / rowSums(simulation_routine$compo[,,150]))
    cwm_df = ab_rel %*% trait_df
    # Values stored in moments_df
    moments_df = as.data.frame(cwm_df)
    colnames(moments_df) = "cwm"
    moments_df = tibble::rownames_to_column(moments_df, "patch")
    moments_df$env = seq(patches)
    # Add CWV
    cwv_df = (ab_rel %*% trait_df^2) - cwm_df^2
    cwv_df = as.data.frame(cwv_df)
    colnames(cwv_df) = "cwv"
    cwv_df = tibble::rownames_to_column(cwv_df, "patch")
    moments_df = dplyr::left_join(moments_df, cwv_df, by = "patch")
    
    return(moments_df)
}

both_cw = compute_moments(single_trait_both, traits)
colnames(both_cw) = c("patch", "both_cwm", "env", "both_cwv")
growth_cw = compute_moments(single_trait_growth, traits)
colnames(growth_cw) = c("patch", "growth_cwm", "env", "growth_cwv")
compet_cw = compute_moments(single_trait_compet, traits)
colnames(compet_cw) = c("patch", "compet_cwm", "env", "compet_cwv")

all_cw = merge(both_cw, growth_cw, c("patch", "env"))
all_cw = merge(all_cw, compet_cw, c("patch", "env"))

all_cwm = tidyr::gather(all_cw, "type", "cwm_value", dplyr::contains("cwm"))
all_cwm = all_cwm[, c("patch", "env", "type", "cwm_value")]
all_cwm$type = gsub( "_.*$", "", all_cwm$type)
all_cwv = tidyr::gather(all_cw, "type", "cwv_value", dplyr::contains("cwv"))
all_cwv = all_cwv[, c("patch", "env", "type", "cwv_value")]
all_cwv$type = gsub( "_.*$", "", all_cwv$type)

all_cw = merge(all_cwm, all_cwv, by = c("patch", "env", "type"))

plot_cwm = ggplot(all_cw, aes(env, cwm_value, fill = type)) +
    geom_abline(slope = 1, intercept = 0) +
    geom_point(shape = 21, color = "black", size = 2) +
    labs(x = "Environmental Value",
         y = "Community Weighted Mean",
         subtitle = "Timestep: 150, Trait Both") +
    scale_fill_manual(labels = c("Both", "Competition only", "Growth only"),
                      values = viridis::viridis(3)) +
    theme_bw()

plot_cwv = ggplot(all_cw, aes(env, cwv_value, fill = type)) +
    geom_point(shape = 21, color = "black", size = 2) +
    labs(x = "Environmental Value",
         y = "Community Weighted Variance",
         subtitle = "Timestep: 150, Trait Both") +
    scale_fill_manual(labels = c(both = "Both",
                                 compet = "Competition only",
                                 growth = "Growth only"),
                      values = viridis::viridis(3)) +
    theme_bw()

plot_grid(plot_cwm,
          plot_grid(plot_cwv,
                    ggplot(all_cw[which(all_cw$type %in% c("growth", "both")), ],
                           aes(env, cwv_value, fill = type)) +
                        geom_point(size = 2, shape = 21, color = "black") +
                        labs(x = "Environmental Value",
                             y = "Community Weighted Variance",
                             subtitle = "Timestep: 150, Trait Both") +
                        scale_fill_manual(labels = c(both = "Both",
                                                     growth = "Growth only"),
                                          values = viridis::viridis(3)[c(1, 3)]) +
                        theme_bw(),
                    nrow = 1),
          nrow = 2)

```


## Generate several traits with various scenarios

### Moderately correlated traits
```{r}
generate_cor_traits = function(number_patches, number_other = 9, cor_coef = 0.7) {
    
    # Initial Trait
    x1 = seq(1, number_patches)
    

    cov_mat = matrix(c(1, cor_coef, 0, sqrt(1 - cor_coef^2)), nrow = 2)
    
    n_other = number_other
    
    res = lapply(seq(n_other), function(x) {
        x2 = runif(number_patches, 1, number_patches)
        
        cov_mat %*% matrix(c(x1, x2), nrow = 2, byrow = TRUE)
    })
    
    res = do.call(rbind, lapply(res, function(x) x[2,]))
    res = rbind(x1, res)
    
    t(res)
}

devtools::load_all()
# Initial parameters -----------------------------------------------------------
patches  <- 25   # Number of patches
species  <- 25   # Number of species
time     <- 150	 # Length of model run (generations)
initpop  <- 50   # initial population size
n_traits <- 4    # number of traits
k        <- 1.45 # Niche height
width    <- seq(10, 10, length.out = patches) # Niche breadth

# Competition + Dispersion coefficients
A =  0.0005	# Alpha scalar 
d = 0.0#5 # Dispersal percentage

# Generate environment
env <- 1:patches

composition <- array(NA, dim = c(patches, species, time),
                     dimnames = list(paste0("patches", 1:patches),
                                     paste0("species", 1:species),
                                     paste0("time", 1:time))) #where values = N
names(env) <- dimnames(composition)[[1]]

composition[,,"time1"] <- initpop # N

# Generate traits --------------------------------------------------------------
set.seed(1)
traits <- generate_cor_traits(patches, n_traits - 1, cor_coef = 0.7)
colnames(traits) <- paste0("trait", seq(n_traits))
rownames(traits) <- paste0("species", seq(species))

# Number of trait influencing growth or competition
trait_types = t(data.frame(prop_8_2 = c(rep("R", round(0.8*n_traits)),
                                        rep("A", n_traits - round(0.8*n_traits))),
                           prop_5_5 = c(rep("R", round(0.5*n_traits)),
                                        rep("A", n_traits - round(0.5*n_traits))),
                           prop_2_8 = c(rep("R", round(0.2*n_traits)),
                                        rep("A", n_traits - round(0.2*n_traits)))))
colnames(trait_types) = colnames(traits)


# Simulations ------------------------------------------------------------------
multiple_traits <- apply(trait_types, 1,
                         function(x){
                             multiple_traits_types = multigen(traits = traits, trait_type = x,
                                                              env = env, time = time, species = species,
                                                              patches = patches, composition = composition,
                                                              A = A, d = d, k = k, width = width)
                         })
names(multiple_traits) <- rownames(trait_types)


# Plots ------------------------------------------------------------------------

# Plot individual patches 
plot_patches_list <- lapply(names(multiple_traits),
                            function(x){
                                plot_patch(multiple_traits[[x]]$compo, 15, 150) +
                                    labs(subtitle = x)
                            })


plot_grid(plotlist = plot_patches_list, ncol = 3)

# Plot species richness
sp_rich_final <- lapply(names(multiple_traits),
                        function(x){
                            nb_ind_final <- multiple_traits[[x]]$compo[,,time]
                            rowSums(nb_ind_final > 2)
                        })

sp_rich_final <- as.data.frame(sp_rich_final)
colnames(sp_rich_final) <- names(multiple_traits)
sp_rich_final <- tibble::rownames_to_column(sp_rich_final, "patch")
sp_rich_final$patch <- as.numeric(gsub("patches", "", sp_rich_final$patch))
sp_rich_final$width <- width

sp_rich_final <- tidyr::gather(sp_rich_final, "prop_type", "richness", dplyr::contains("prop"))

plot_prop_sp_rich <- ggplot(sp_rich_final, aes(1/width, richness, color = prop_type)) +
    geom_line(size = 1) +
    scale_color_manual(values = viridis::viridis(3)) +
    xlab("Environmental intensity (1/width)") +
    ylab("Patch richness")

plot_prop_sp_rich_patch <- ggplot(sp_rich_final, aes(patch, richness, color = prop_type)) +
    geom_line(size = 1) +
    scale_color_manual(values = viridis::viridis(3)) +
    xlab("Patch Index") +
    ylab("Patch richness")

```

```{r FD_compute}
# Compute FD metrics -----------------------------------------------------------
# Compute FD metrics (richness, dispersion, eveness)
timestep = 150
FD_prop <- lapply(names(multiple_traits),
                  function(x) {
                      
                      
                      patch_sp_timestep <- multiple_traits[[x]]$compo[,,timestep]
                      ab_rel = patch_sp_timestep / rowSums(patch_sp_timestep)
                      ab_rel = ab_rel[!is.na(rowSums(ab_rel)), ]
                      
                      # Compute Functional Diversity at Patch Scale
                      FD_patches <- sapply(seq_len(nrow(ab_rel)), function(y){
                          ab_patch = ab_rel[y, ][ab_rel[y, ] > 0] # Removal of species with null abundance
                          if (length(ab_patch) > 1) { # Patch must contain at least 2 species
                              FD_patch = dbFD(traits[rownames(traits) %in%
                                                         names(ab_patch), ],
                                              a = ab_patch,
                                              w.abun = TRUE)
                              
                              data.frame(prop = x,
                                         patch = rownames(ab_rel[y, , drop = FALSE]),
                                         frich = FD_patch$FRic,
                                         fdis = FD_patch$FDis,
                                         feve = FD_patch$FEve)
                          }
                      }, simplify = FALSE)
                      bind_rows(FD_patches)
                  })
FD_prop <- bind_rows(FD_prop)

width_df <- data.frame(patch = paste0("patches", 1:patches),
                       width = width)
FD_prop <- merge(FD_prop, width_df, by = "patch")

FD_prop$patch <- as.numeric(gsub("patches", "", FD_prop$patch))

FD_melt <- tidyr::gather(FD_prop, "fd_metric", "fd_value", frich:feve)

# Plot FD against environmental filtering strength
plot_prop_frich <- ggplot(FD_prop, aes(1/width, frich, color = prop)) +
    geom_line(size = 1) +
    scale_color_manual(values = viridis::viridis(3)) +
    xlab("Environmental intensity (1/width)") +
    ylab("Patch functional richness") +
    theme(legend.position = "none")
plot_prop_fdis <- ggplot(FD_prop, aes(1/width, fdis, color = prop)) +
    geom_line(size = 1) +
    scale_color_manual(values = viridis::viridis(3)) +
    xlab("Environmental intensity (1/width)") +
    ylab("Patch functional dispersion") +
    theme(legend.position = "none")
plot_prop_feve <- ggplot(FD_prop, aes(1/width, feve, color = prop)) +
    geom_line(size = 1) +
    scale_color_manual("Proportion of traits\ncontributing to R A",
                       values = viridis::viridis(3)) +
    xlab("Environmental intensity (1/width)") +
    ylab("Patch functional evenness")

plot_grid(plot_prop_frich, plot_prop_fdis, plot_prop_feve, nrow = 1)

plot_fd_patch <- ggplot(FD_melt, aes(patch, fd_value, color = prop)) +
    geom_line() +
    facet_grid(fd_metric~., scales = "free_y") +
    scale_color_manual("Proportion of traits\ncontributing to R A",
                       values = viridis::viridis(3)) +
    labs(x = "Patch Index",
         y = "FD value")
```

```{r null_models}
# Null models ------------------------------------------------------------------
# Null models: resample species within each patch (NM2)
# FD null for each proportion case
nb_perm = 99#99
timestep = 10
FD_null_prop <- lapply(names(multiple_traits),
                       function(x){
                           # Null model 2 (Bernard-Verdier et al. 2012) => shuffling abundances of species within patches
                           null_matrices <- replicate(nb_perm,
                                                      t(apply(multiple_traits[[x]]$compo[, , timestep], 1, sample)),
                                                      simplify = FALSE)
                           # Convert to relative abundances
                           null_matrices <- lapply(null_matrices, function(y) y/rowSums(y))
                           # Add species in column names
                           null_matrices = lapply(null_matrices, as.data.frame)
                           null_matrices = lapply(null_matrices, setNames, paste0("species", seq(species)))
                           # Remove empty rows in null matrices
                           null_matrices = lapply(null_matrices, function(x) x[!is.na(rowSums(x)), ])
                           
                           # FD computation over the null matrices
                           FD_null <- lapply(null_matrices,
                                             function(y){
                                                 FD_null_patches <- sapply(seq_len(nrow(y)), function(z){
                                                     ab_patch = y[z, ]
                                                     ab_patch = ab_patch[, colSums(ab_patch) > 0] # Removal of species with null abundance
                                                     #ab_patch = z[, z > 0, drop = FALSE] 
                                                     if(length(ab_patch) > 1){ # Patch must contain at least 2 species
                                                         FD_patch = dbFD(traits[rownames(traits) %in%
                                                                                    names(ab_patch), ],
                                                                         a = ab_patch,
                                                                         w.abun = TRUE)
                                                         data.frame(prop = x,
                                                                    patch = rownames(ab_patch),
                                                                    frich = FD_patch$FRic,
                                                                    fdis = FD_patch$FDis,
                                                                    feve = FD_patch$FEve)
                                                     }
                                                 })
                                                 FD_null_patches <- do.call(rbind, FD_null_patches)
                                             })
                           FD_null <- do.call(rbind, FD_null)
                           
                           FD_null <- group_by(FD_null, patch)
                           FD_null <- summarise_if(FD_null,
                                                   is.numeric,
                                                   list(mean = function(x) mean(x, na.rm = TRUE),
                                                        sd = function(x) sd(x, na.rm = TRUE)))
                           FD_null <- data.frame(FD_null)
                           FD_null$prop <- x
                           return(FD_null)
                       })

FD_null_prop <- do.call(rbind, FD_null_prop)

# Compute FD SES ---------------------------------------------------------------
FD_prop <- left_join(FD_prop, FD_null_prop, by = c("prop", "patch"))
FD_prop$frich_SES <- (FD_prop$frich - FD_prop$frich_mean) / FD_prop$frich_sd
FD_prop$fdis_SES <- (FD_prop$fdis - FD_prop$fdis_mean) / FD_prop$fdis_sd
FD_prop$feve_SES <- (FD_prop$feve - FD_prop$feve_mean) / FD_prop$feve_sd

# Plot FD SES ------------------------------------------------------------------
plot_prop_frich_SES <- ggplot(FD_prop, aes(1/width, frich_SES, color = as.factor(prop))) +
    geom_line(size = 1) +
    scale_color_manual(values = viridis::viridis(3)) +
    xlab("Environmental intensity (1/width)") +
    ylab("Patch functional richness SES") +
    theme(legend.position = "none")

plot_prop_fdis_SES <- ggplot(FD_prop, aes(1/width, fdis_SES, color = prop)) +
    geom_line(size = 1) +
    scale_color_manual(values = viridis::viridis(3)) +
    xlab("Environmental intensity (1/width)") +
    ylab("Patch functional dispersion SES") +
    theme(legend.position = "none")

plot_prop_feve_SES <- ggplot(FD_prop, aes(1/width, feve_SES, color = prop)) +
    geom_line(size = 1) +
    scale_color_manual("Proportion of traits\ncontributing to R A",
                       values = viridis::viridis(3)) +
    xlab("Environmental intensity (1/width)") +
    ylab("Patch functional evenness SES")

plot_grid(plot_prop_frich_SES, plot_prop_fdis_SES, plot_prop_feve_SES, nrow = 1)

```



