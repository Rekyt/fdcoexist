---
title: "Coexistence with varying environmental filtering intensity"
author: "XX"
date: "5 juin 2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(cowplot)
```

# Single trait

```{r}
devtools::load_all()
#### Keep stable for all
patches  <- 25   # Number of patches
species  <- 25   # Number of species
time     <- 150	 # Length of model run (generations)
initpop  <- 50   # initial population size
n_traits <- 1    # number of traits
k        <- 1.45 # Niche height
width    <- seq(10, 0.25, length.out = patches) # Niche breadth

# Competition + Dispersion coefficients
A =  0.0005	# Alpha scalar 
d = 0.0#5 # Dispersal percentage

# Generate environment
env <- 1:patches

composition <- array(NA, dim = c(patches, species, time),
                     dimnames = list(paste0("patches", 1:patches),
                                     paste0("species", 1:species),
                                     paste0("time", 1:time))) #where values = N
names(env) <- dimnames(composition)[[1]]

composition[,,"time1"] <- initpop # N

# Generate traits
traits <- generate_traits(species,
                          rep(min(env), n_traits),
                          rep(max(env), n_traits))

# Single trait competition, single trait growth, single trait both -------------
# Goal: compare between the three above-mentioned cases

## Single Trait Competition
trait_type = c(trait1 = "A")
single_trait_compet = multigen(traits = traits, trait_type = trait_type,
                               env = env, time = time, species = species,
                               patches = patches, composition = composition,
                               A = A, d = d, k = k, width = width)
single_trait_compet_final = ifelse(single_trait_compet$compo[,,time] < 2, 0, single_trait_compet$compo[,,time])

## Single Trait Growth
trait_type = c(trait1 = "R")
single_trait_growth = multigen(traits = traits, trait_type = trait_type,
                               env = env, time = time, species = species,
                               patches = patches, composition = composition,
                               A = A, d = d, k = k, width = width)
single_trait_growth_final = ifelse(single_trait_growth$compo[,,time] < 2, 0,
                                   single_trait_growth$compo[,,time])

## Both
trait_type = c(trait1 = "RA")
single_trait_both = multigen(traits = traits, trait_type = trait_type,
                             env = env, time = time, species = species,
                             patches = patches, composition = composition,
                             A = A, d = d, k = k, width = width)

single_trait_both_final = ifelse(single_trait_both$compo[,,time] < 2, 0,
                                 single_trait_both$compo[,,time])

```

```{r}
p5_comp = plot_patch(single_trait_compet$compo, 5, 150) +
    labs(subtitle = "Competition")
p5_grow = plot_patch(single_trait_growth$compo, 5, 150) +
    labs(subtitle = "Growth")
p5_both = plot_patch(single_trait_both$compo,   5, 150) +
    labs(subtitle = "Both")

p15_comp = plot_patch(single_trait_compet$compo, 15, 150) +
    labs(subtitle = "Competition")
p15_grow = plot_patch(single_trait_growth$compo, 15, 150)  +
    labs(subtitle = "Growth")
p15_both = plot_patch(single_trait_both$compo,   15, 150) +
    labs(subtitle = "Both")

plot_patches = plot_grid(p5_grow, p5_comp, p5_both, p15_grow, p15_comp,
                         p15_both, ncol = 3, nrow = 2)
plot_patches
```

## Compute CWM & CWV

```{r}
compute_moments = function(simulation_routine, trait_df = traits) {
    # CWM computation
    ab_rel = (simulation_routine$compo[,,150] / rowSums(simulation_routine$compo[,,150]))
    cwm_df = ab_rel %*% trait_df
    # Values stored in moments_df
    moments_df = as.data.frame(cwm_df)
    colnames(moments_df) = "cwm"
    moments_df = tibble::rownames_to_column(moments_df, "patch")
    moments_df$env = seq(patches)
    # Add CWV
    cwv_df = (ab_rel %*% trait_df^2) - cwm_df^2
    cwv_df = as.data.frame(cwv_df)
    colnames(cwv_df) = "cwv"
    cwv_df = tibble::rownames_to_column(cwv_df, "patch")
    moments_df = dplyr::left_join(moments_df, cwv_df, by = "patch")
    
    return(moments_df)
}

both_cw = compute_moments(single_trait_both, traits)
colnames(both_cw) = c("patch", "both_cwm", "env", "both_cwv")
growth_cw = compute_moments(single_trait_growth, traits)
colnames(growth_cw) = c("patch", "growth_cwm", "env", "growth_cwv")
compet_cw = compute_moments(single_trait_compet, traits)
colnames(compet_cw) = c("patch", "compet_cwm", "env", "compet_cwv")

all_cw = merge(both_cw, growth_cw, c("patch", "env"))
all_cw = merge(all_cw, compet_cw, c("patch", "env"))

all_cwm = tidyr::gather(all_cw, "type", "cwm_value", dplyr::contains("cwm"))
all_cwm = all_cwm[, c("patch", "env", "type", "cwm_value")]
all_cwm$type = gsub( "_.*$", "", all_cwm$type)
all_cwv = tidyr::gather(all_cw, "type", "cwv_value", dplyr::contains("cwv"))
all_cwv = all_cwv[, c("patch", "env", "type", "cwv_value")]
all_cwv$type = gsub( "_.*$", "", all_cwv$type)

all_cw = merge(all_cwm, all_cwv, by = c("patch", "env", "type"))

plot_cwm = ggplot(all_cw, aes(env, cwm_value, fill = type)) +
    geom_abline(slope = 1, intercept = 0) +
    geom_point(shape = 21, color = "black", size = 2) +
    labs(x = "Environmental Value",
         y = "Community Weighted Mean",
         subtitle = "Timestep: 150, Trait Both") +
    scale_fill_manual(labels = c("Both", "Competition only", "Growth only"),
                      values = viridis::viridis(3)) +
    theme_bw()

plot_cwv = ggplot(all_cw, aes(env, cwv_value, fill = type)) +
    geom_point(shape = 21, color = "black", size = 2) +
    labs(x = "Environmental Value",
         y = "Community Weighted Variance",
         subtitle = "Timestep: 150, Trait Both") +
    scale_fill_manual(labels = c(both = "Both",
                                 compet = "Competition only",
                                 growth = "Growth only"),
                      values = viridis::viridis(3)) +
    theme_bw()

plot_grid(plot_cwm,
          plot_grid(plot_cwv,
                    ggplot(all_cw[which(all_cw$type %in% c("growth", "both")), ],
                           aes(env, cwv_value, fill = type)) +
                        geom_point(size = 2, shape = 21, color = "black") +
                        labs(x = "Environmental Value",
                             y = "Community Weighted Variance",
                             subtitle = "Timestep: 150, Trait Both") +
                        scale_fill_manual(labels = c(both = "Both",
                                                     growth = "Growth only"),
                                          values = viridis::viridis(3)[c(1, 3)]) +
                        theme_bw(),
                    nrow = 1),
          nrow = 2)

```

```{r}

devtools::load_all()
#### Keep stable for all
patches  <- 25   # Number of patches
species  <- 25   # Number of species
time     <- 150	 # Length of model run (generations)
initpop  <- 50   # initial population size
n_traits <- 10    # number of traits
k        <- 1.45 # Niche height
width    <- seq(10, 0.25, length.out = patches) # Niche breadth

# Competition + Dispersion coefficients
A =  0.0005	# Alpha scalar 
d = 0.0#5 # Dispersal percentage

# Generate environment
env <- 1:patches

composition <- array(NA, dim = c(patches, species, time),
                     dimnames = list(paste0("patches", 1:patches),
                                     paste0("species", 1:species),
                                     paste0("time", 1:time))) #where values = N
names(env) <- dimnames(composition)[[1]]

composition[,,"time1"] <- initpop # N

# Generate traits
set.seed(1)
traits <- matrix(runif(species*n_traits, min(env), max(env)),
                 species,
                 n_traits)
colnames(traits) <- paste0("trait", seq(n_traits))
rownames(traits) <- paste0("species", seq(species))

# Number of trait influencing growth or competition
trait_types = t(data.frame(prop1 = c(rep("R", 8), rep("A", 2)),
                           prop2 = c(rep("R", 5), rep("A", 5)),
                           prop3 = c(rep("R", 2), rep("A", 8))))
colnames(trait_types) = colnames(traits)

multiple_traits <- apply(trait_types, 1,
                         function(x){
                             multiple_traits_types = multigen(traits = traits, trait_type = x,
                                                              env = env, time = time, species = species,
                                                              patches = patches, composition = composition,
                                                              A = A, d = d, k = k, width = width)
                         })
names(multiple_traits) <- rownames(trait_types)

plot_patches_list <- lapply(names(multiple_traits),
                            function(x){
                                plot_patch(multiple_traits[[x]]$compo, 15, 150) +
                                    labs(subtitle = x)
                            })


plot_grid(plotlist = plot_patches_list, ncol = 3)

# Plot species richness
sp_rich_final <- lapply(names(multiple_traits),
                        function(x){
                            nb_ind_final <- multiple_traits[[x]]$compo[,,time]
                            rowSums(nb_ind_final > 2)
                        })

sp_rich_final <- as.data.frame(sp_rich_final)
colnames(sp_rich_final) <- names(multiple_traits)
sp_rich_final$width <- width

sp_rich_final <- tidyr::gather(sp_rich_final, "prop_type", "richness", dplyr::contains("prop"))

plot_prop_sp_rich <- ggplot(sp_rich_final, aes(1/width, richness, color = prop_type)) +
    geom_line(size = 1) +
    scale_color_manual(values = viridis::viridis(3)) +
    xlab("Environmental intensity (1/width)") +
    ylab("Patch richness")

# Compute FD metrics (richness, dispersion, eveness)
library(FD)
timestep = 10
FD_prop <- lapply(names(multiple_traits),
                  function(x){
                      patch_sp_timestep <- multiple_traits[[x]]$compo[,,timestep]
                      ab_rel = patch_sp_timestep / rowSums(patch_sp_timestep)
                      ab_rel = ab_rel[!is.na(rowSums(ab_rel)), ]
                      FD_patches <- sapply(seq_len(nrow(ab_rel)), function(y){
                          ab_patch = ab_rel[y, ][ab_rel[y, ] > 0] # Removal of species with null abundance
                          if(length(ab_patch) > 1){ # Patch must contain at least 2 species
                              FD_patch = dbFD(traits[rownames(traits) %in%
                                                         names(ab_patch), ],
                                              a = ab_patch,
                                              w.abun = TRUE)
                              data.frame(prop = x,
                                         patch = rownames(ab_rel[y, , drop = FALSE]),
                                         frich = FD_patch$FRic,
                                         fdis = FD_patch$FDis,
                                         feve = FD_patch$FEve)
                          }
                      })
                      FD_patches <- do.call(rbind, FD_patches)
                  })
FD_prop <- do.call(rbind, FD_prop)

width_df <- data.frame(patch = paste0("patches", 1:patches),
                       width = width)
FD_prop <- merge(FD_prop, width_df, by = "patch")

# Plot FD against environmental filtering strength
plot_prop_frich <- ggplot(FD_prop, aes(1/width, frich, color = prop)) +
    geom_line(size = 1) +
    scale_color_manual(values = viridis::viridis(3)) +
    xlab("Environmental intensity (1/width)") +
    ylab("Patch functional richness") +
    theme(legend.position = "none")
plot_prop_fdis <- ggplot(FD_prop, aes(1/width, fdis, color = prop)) +
    geom_line(size = 1) +
    scale_color_manual(values = viridis::viridis(3)) +
    xlab("Environmental intensity (1/width)") +
    ylab("Patch functional dispersion") +
    theme(legend.position = "none")
plot_prop_feve <- ggplot(FD_prop, aes(1/width, feve, color = prop)) +
    geom_line(size = 1) +
    scale_color_manual("Proportion of traits\ncontributing to R A",
                       values = viridis::viridis(3)) +
    xlab("Environmental intensity (1/width)") +
    ylab("Patch functional evenness")

plot_grid(plot_prop_frich, plot_prop_fdis, plot_prop_feve, nrow = 1)

##
# Null models: resample species amongst patches
po = multiple_traits[["prop1"]]$compo[, , 10]
nb_perm = 9#999
# Null model 2 (Bernard-Verdier et al. 2012) => shuffling abundances of species within patches
null_matrices <- replicate(nb_perm, t(apply(po, 1, sample)), simplify = FALSE)
# Convert to relative abundances
null_matrices <- lapply(null_matrices, function(y) y/rowSums(y))
# Add species in column names
null_matrices = lapply(null_matrices, as.data.frame)
null_matrices = lapply(null_matrices, setNames, paste0("species", seq(species)))
# Remove empty rows in null matrices
null_matrices = lapply(null_matrices, function(x) x[!is.na(rowSums(x)), ])

# FD computation over the null matrices
FD_null <- lapply(null_matrices,
                  function(y){
                      FD_null_patches <- sapply(seq_len(nrow(y)), function(z){
                          ab_patch = y[z, ]
                          ab_patch = ab_patch[, colSums(ab_patch) > 0] # Removal of species with null abundance
                          #ab_patch = z[, z > 0, drop = FALSE] 
                          if(length(ab_patch) > 1){ # Patch must contain at least 2 species
                              FD_patch = dbFD(traits[rownames(traits) %in%
                                                         names(ab_patch), ],
                                              a = ab_patch,
                                              w.abun = TRUE)
                              data.frame(prop = "prop1", # => x
                                         patch = rownames(ab_patch),
                                         frich = FD_patch$FRic,
                                         fdis = FD_patch$FDis,
                                         feve = FD_patch$FEve)
                          }
                      })
                      FD_null_patches <- do.call(rbind, FD_null_patches)
                  })
FD_null <- do.call(rbind, FD_null)

library(dplyr)
FD_null2 <- group_by(FD_null, prop)
FD_null2 <- summarise_if(FD_null2,
                         is.numeric,
                         list(mean = function(x) mean(x, na.rm = TRUE),
                              sd = function(x) sd(x, na.rm = TRUE)))


tapply(FD_null$frich, FD_null$patch, mean, na.rm = TRUE)
tapply(FD_null$frich, FD_null$patch, sd, na.rm = TRUE)
FD_SES

# Standard effect size
# (obs - mean(Null)) / sigma(Null)

```



