---
title: "fdcoexist simulate with various parameters and traits"
author:
    - Pierre Denelle, Matthias Grenié, Cyrille Violle, François Munoz and Caroline M. Tucker
date: "`r format(Sys.time(), '%d %B %Y')`"
output: pdf_document
vignette: >
  %\VignetteIndexEntry{Full equation of the model}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
editor_options: 
  chunk_output_type: console
---

```{r setup, echo=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE,
                      fig.width = 8, fig.height = 10.5, cache = TRUE)

# Packages ---------------------------------------------------------------------
suppressPackageStartupMessages({
    suppressWarnings({
        library("cowplot")
        library("tidyr")
        library("dplyr")
        library("purrr")
        library("forcats")
        library("ggplot2")
        library("stringr")
        library("tibble")
        library("directlabels")
        library("furrr")
    })
})

plan(sequential)
# Functions --------------------------------------------------------------------
extract_trait_contrib_from_scenar = function(scenario) {
    R_scenar = as.integer(sub("R(\\d+).*", "\\1", scenario, perl = TRUE))
    A_scenar = as.integer(sub(".*A(\\d+).*", "\\1", scenario, perl = TRUE))
    H_scenar = as.integer(sub(".*H(\\d+)", "\\1", scenario, perl = TRUE))
    
    list(R = R_scenar,
         A = A_scenar,
         H = H_scenar)
}

extract_simul_param_and_abund = function(single_simul, time = 150) {
    
    scenario = single_simul$scenario
    
    contrib = extract_trait_contrib_from_scenar(scenario)
    
    given_k = single_simul$k
    
    if (length(given_k) == 1) {
        given_k = paste0("fixed = ", given_k)
    } else {
        given_k = "gaussian"
    }
    
    single_simul$compo[[1]][,,time] %>%
        as.data.frame() %>%
        rownames_to_column("patch") %>%
        gather("species", "N", -patch) %>%
        mutate(patch = gsub("patches", "", patch) %>%
                   as.numeric(),
               R_scenar = contrib$R,
               A_scenar = contrib$A,
               H_scenar = contrib$H) %>%
        group_by(patch) %>%
        # add simulation parameters and relative abundance
        mutate(rel_abund = N/sum(N),
               seed      = single_simul$seed,
               k         = given_k,
               A         = single_simul$A,
               B_over_A  = single_simul$B_over_A,
               H         = single_simul$H,
               h_fun     = single_simul$h_fun,
               trait_cor = single_simul$traits) %>%
        ungroup() %>%
        select(seed, trait_cor, k, h_fun, A, B_over_A, H, R_scenar, A_scenar,
               H_scenar, everything())
}

# This function tidy a list of simulation routine to a single data.frame
# suitable to make figures.
tidy_simulation_list = function(simulation_list, list_of_trait_df, time = 150) {
    
    full_trait_df = list_of_trait_df %>%
        map_dfr(~.x %>%
                    as.data.frame() %>%
                    rownames_to_column("species"),
                .id = "trait_cor")
    
    simulation_list %>%
        # Tidy single simulations
        map_dfr(extract_simul_param_and_abund, time = time) %>%
        inner_join(full_trait_df, by = c("trait_cor", "species"))
}

compute_site_cwm_cwv_sr = function(simulation_df) {
    
    group_site = simulation_df %>%
        group_by(seed, trait_cor, k, h_fun, A, B_over_A, H, R_scenar, A_scenar,
                 H_scenar, patch)
    
    rich_df = group_site %>%
        summarise(species_rich = sum(N > 0, na.rm = TRUE))
    
    group_site %>%
        summarise_at(vars(tidyselect::matches("trait\\d")),
                     funs(cwm = weighted.mean(., N, na.rm = TRUE),
                          cwv = Hmisc::wtd.var(., N, na.rm = TRUE))) %>%
        inner_join(rich_df) %>%
        ungroup()
}

extract_performances_from_simul = function(simul, trait_df,
                                           compute_realized_growth_rate = TRUE) {
    
    given_compo = simul$compo[[1]]
    
    contrib = extract_trait_contrib_from_scenar(simul$scenario)
    
    given_k = simul$k
    
    if (length(given_k) == 1) {
        given_k = paste0("fixed = ", given_k)
    } else {
        given_k = "gaussian"
    }
    
    th_growth_rate = simul$rmatrix %>%
        as_tibble() %>%
        rownames_to_column("patch") %>%
        mutate(patch = as.numeric(patch)) %>%
        gather("species", "th_growth_rate", -patch)
    
    env_growth_rate = simul$rmatenv %>%
        as_tibble() %>%
        rownames_to_column("patch") %>%
        mutate(patch = as.numeric(patch)) %>%
        gather("species", "env_growth_rate", -patch)
    
    lapply(seq_len(nrow(given_compo)), function(site_index) {
        
        site_abund = given_compo[site_index,,]
        
        if (compute_realized_growth_rate) {
            
            # Estimate maximum growth rate
            max_growth = apply(site_abund, 1, function(given_abund) {
                
                # Get first moment where species goes extinct
                time_before_extinct = which(given_abund == 0)[1] - 1
                
                # When species doesn't go extinct consider maximum time
                if (is.na(time_before_extinct)) {
                    time_before_extinct = length(given_abund)
                }
                
                growth_rate = NA_real_
                
                if (time_before_extinct > 10) {
                    given_time = 1:time_before_extinct
                    
                    growth_model = growthrates::fit_spline(given_time,
                                                           given_abund[given_time])
                    
                    growth_rate = growth_model@par[["mumax"]]
                }
                
                ifelse(is.null(growth_rate), NA_real_, growth_rate)
            }) %>%
                enframe("species", "max_growth_rate")
        } else {
            max_growth = data.frame(species = rownames(site_abund),
                                    max_growth_rate = NA)
        }
        
        # Get optimality
        optim_dist = apply(trait_df, 1, function(given_traits) {
            weighted.mean(abs(site_index - given_traits), c(0.5, 0.5, 0, 0))
        }) %>%
            enframe("species", "distance_to_optimum")
        
        
        # Abundance
        sp_abund = site_abund[, 150] %>%
            enframe("species", "N150") %>%
            mutate(patch = site_index) %>%
            select(patch, everything())
        
        
        # Combine all data
        sp_abund %>%
            inner_join(optim_dist, by = "species") %>%
            inner_join(max_growth, by = "species")
    }) %>%
        bind_rows() %>%
        inner_join(th_growth_rate, by = c("patch", "species")) %>%
        inner_join(env_growth_rate, by = c("patch", "species")) %>%
        mutate(seed      = simul$seed,
               trait_cor = simul$traits,
               k         = given_k,
               A         = simul$A,
               B_over_A  = simul$B_over_A,
               H         = simul$H,
               R_scenar  = contrib$R,
               A_scenar  = contrib$A,
               H_scenar  = contrib$H) %>%
        mutate_at(vars(contains("growth_rate")), funs(per_capita = . / N150))
}

extract_caption = function(simul_df) {
    given_n_seed    = length(unique(simul_df$seed))
    given_trait_cor = unique(simul_df$trait_cor)
    given_k         = unique(simul_df$k)
    given_h_fun     = unique(simul_df$h_fun)
    given_A         = unique(simul_df$A)
    given_B_over_A  = unique(simul_df$B_over_A)
    given_H         = unique(simul_df$H)
    
    param_caption = paste0(given_n_seed, " simuls.; ",
                           cor_labs[[given_trait_cor]], "; ",
                           gsub("fixed", "fixed k", given_k), "; ",
                           h_fun_labs[[given_h_fun]], "; ",
                           "A = ", given_A, "; ",
                           "B/A = ", given_B_over_A, "; ",
                           "H = ", given_H)
}
# Initial parameters -----------------------------------------------------------
suppressMessages(devtools::load_all())

n_patches <- 25   # Number of patches
n_species <- 100  # Number of species
n_gen     <- 150  # Length of model run (generations)
initpop   <- 50   # initial population size
n_traits  <- 4    # number of traits
k         <- 1.15 # Maximum growth rate
env_width <- rep(5, length.out = n_patches)  # Envtal filter strength
total_runs = 20  # Number of set of traits to test

# Competition + Dispersion coefficients
B = 2e-4       # Scalar for intraspecific competition
A = 2e-4       # Alpha scalar
d = 0.05       # Dispersal percentage
dist_power = 2 # Power of trait dissimilarity

# Hierarchical coefficients
H = 1.5
th_max = 25

# Generate environment
env <- seq(n_patches)

# Array for simulations
composition <- array(NA, dim = c(n_patches, n_species, n_gen),
                     dimnames = list(paste0("patches", seq(n_patches)),
                                     paste0("species", seq(n_species)),
                                     paste0("time", seq(n_gen))))
names(env) <- dimnames(composition)[[1]]

composition[,, "time1"] <- initpop

# Define scenarios -------------------------------------------------------------
# Scenarios on traits affecting growth and competition
trait_scenarios = c("R0A0", "R0A100", "R10A90", "R25A75", "R50A50", "R75A25",
                    "R90A10", "R100A0", "R100A100")

names(trait_scenarios) = trait_scenarios

trait_scenarios = lapply(trait_scenarios, function(scenar_name) {
    growth = as.numeric(gsub("R(\\d+)A\\d+", "\\1", scenar_name, perl = TRUE))
    compet = as.numeric(gsub("R\\d+A(\\d+)", "\\1", scenar_name, perl = TRUE))
    
    create_trait_weights(growth, compet, 0)
})

# Define meta-function to run all analyses with many trait levels --------------

meta_simul_A_B_k_and_H = function(seed_number, given_k = k, given_A = A,
                                  given_B_over_A = B/A,
                                  given_H = H, given_scenars = NULL,
                                  given_traits = NULL,
                                  given_h_fun  = "sum") {
    
    our_scenars = list(R50A50H50 = create_trait_weights(50, 50, 50))
    
    if (!is.null(given_scenars)) {
        our_scenars = given_scenars
    }
    
    set.seed(seed_number)
    uncor_traits = generate_cor_traits(n_patches, n_species, n_traits - 1,
                                       cor_coef = 0)
    all_cor = list(uncor = uncor_traits)
    
    if (!is.null(given_traits)) {
        all_cor = given_traits
    }
    
    guessed_th_max = lapply(all_cor, max)
    guessed_th_max = max(unlist(guessed_th_max))
    
    all_env = list(constant = env_width)
    
    all_compet = list(compet = list(A        = given_A,
                                    B        = given_A * given_B_over_A,
                                    H        = given_H,
                                    B_over_A = given_B_over_A))

    
    all_facets = expand.grid(compet_status = names(all_compet),
                             env_width     = names(all_env),
                             cor_level     = names(all_cor),
                             scenario      = names(our_scenars))
    
    apply(all_facets, 1, function(given_row) {
        simul = multigen(
            traits        = all_cor[[given_row[["cor_level"]]]],
            trait_weights = our_scenars[[given_row[["scenario"]]]],
            env           = env,
            time          = n_gen,
            species       = n_species,
            patches       = n_patches,
            composition   = composition,
            A             = all_compet[[given_row[["compet_status"]]]][["A"]],
            B             = all_compet[[given_row[["compet_status"]]]][["B"]],
            d             = d,
            k             = given_k,
            dist_power    = dist_power,
            H             = all_compet[[given_row[["compet_status"]]]][["H"]],
            th_max        = guessed_th_max,
            width         = all_env[[given_row[["env_width"]]]],
            h_fun         = given_h_fun)
        
        return(
            list(
                k             = given_k,
                A             = all_compet[[given_row[["compet_status"]]]][["A"]],
                B_over_A      = all_compet[[given_row[["compet_status"]]]][["B_over_A"]],
                H             = all_compet[[given_row[["compet_status"]]]][["H"]],
                seed          = seed_number,
                compet_status = given_row[["compet_status"]],
                env           = given_row[["env_width"]],
                traits        = given_row[["cor_level"]],
                scenario      = given_row[["scenario"]],
                compo         = list(simul$compo),
                rmatrix       = simul$rmatrix,
                rmatenv       = simul$rmatenv,
                h_fun         = given_h_fun))
    })
}
# Generate traits --------------------------------------------------------------
trait_seed = 5
# Make traits with different correlations
set.seed(trait_seed)
uncor_traits = generate_cor_traits(n_patches, n_species, n_traits - 1,
                                   cor_coef = 0, min_value = 1)
set.seed(trait_seed)
low_cor_traits = generate_cor_traits(n_patches, n_species, n_traits - 1,
                                     cor_coef = 0.3, min_value = 1)

set.seed(trait_seed)
high_cor_traits = generate_cor_traits(n_patches, n_species, n_traits - 1,
                                      cor_coef = 0.7, min_value = 1)


# Graphical parameters ---------------------------------------------------------
theme_set(theme_bw(12))

# Graphical functions ----------------------------------------------------------
lab_cor = c(uncor    = "r = 0",
            low_cor  = "r = 0.3",
            high_cor = "r = 0.7")

cor_labs = c(uncor   = "No trait correlation",
            low_cor  = "Medium trait correlation",
            high_cor = "High trait correlation")

triangle_labs = c(N150                = "Abundance at time = 150",
                  max_growth_rate     = "Maximum Growth Rate",
                  distance_to_optimum = "Distance to Optimum")

var_labs = c(k        = "k (maximum growth rate)",
             A        = "A (interspecific competition)",
             B_over_A = "B/A (ratio intra/inter)",
             H        = "H (advantage of hierarchical competition)")

h_fun_labs = c(sum  = "additive H",
               prod = "multiplicative H")
```

## Number of coexisting species depending on A, B/A, k and H

```{r param_space_simuls}
list_A = 10^-(seq(2, 6, length.out = 5))
list_k = seq(1, 1.5, length.out = 5)
list_B_over_A = 10^seq(0, 4, length.out = 5)
list_H = seq(0, 2, length.out = 5)

plan(multiprocess, workers = 15)
tictoc::tic()

var_a_var_k_var_ba = list(
    run_n    = seq(1),
    A        = list_A,
    k        = list_k,
    B_over_A = list_B_over_A,
    H        = list_H) %>%
    cross() %>%
    future_map(function(x) {
    devtools::load_all()
    
    meta_simul_A_B_k_and_H(x$run_n, x$k, x$A, x$B_over_A,
                           given_H = x$H)
}, .progress = TRUE)
tictoc::toc()
```

```{r extract_info_var_params}
set.seed(1)
used_traits = list(
    uncor = generate_cor_traits(n_patches, n_species, n_traits - 1,
                                  cor_coef = 0))

var_ba_df = var_a_var_k_var_ba %>%
    map_dfr(~tidy_simulation_list(.x, used_traits))

var_ba_cwm_sr_df = compute_site_cwm_cwv_sr(var_ba_df) %>%
    mutate(k = as.numeric(gsub("fixed = ", "", k, fixed = TRUE)))
```

```{r biplot_of_parameters_richness}
plot_species_richness = function(var_df, x_var, y_var, given_labs = var_labs) {
    
    not_used_vars = setdiff(names(given_labs), c(x_var, y_var))
    
    var_df %>%
        ggplot(aes_string(x_var, y_var)) +
        stat_summary_2d(aes(z = species_rich), fun = "mean", geom = "raster") +
        facet_wrap(~patch) +
        scale_fill_viridis_c(limits = c(0, 100)) +
        labs(x = var_labs[[x_var]],
             y = var_labs[[y_var]],
             fill = "Species Richness\n(at t = 150)",
             subtitle = paste0("Avg. SR over values of ",
                               paste(not_used_vars, collapse = " and "))) +
        theme(legend.position = "top",
              legend.text = element_text(angle = 45),
              aspect.ratio = 1)
}

plot_k_A = var_ba_cwm_sr_df %>%
    filter(patch %in% c(1, 13)) %>%
    plot_species_richness("k", "A") +
    scale_y_log10()

plot_A_BA = var_ba_cwm_sr_df %>%
    filter(patch %in% c(1, 13)) %>%
    plot_species_richness("A", "B_over_A") +
    scale_x_log10() +
    scale_y_log10()

plot_k_BA = var_ba_cwm_sr_df %>%
    filter(patch %in% c(1, 13)) %>%
    plot_species_richness("k", "B_over_A") +
    scale_y_log10()

plot_k_H = var_ba_cwm_sr_df %>%
    filter(patch %in% c(1, 13)) %>%
    plot_species_richness("k", "H")

plot_A_H = var_ba_cwm_sr_df %>%
    filter(patch %in% c(1, 13)) %>%
    plot_species_richness("A", "H") +
    scale_x_log10()

plot_BA_H = var_ba_cwm_sr_df %>%
    filter(patch %in% c(1, 13)) %>%
    plot_species_richness("B_over_A", "H") +
    scale_x_log10()

sr_grid = plot_grid(plot_k_A,
          plot_k_H,
          plot_A_BA,
          plot_A_H,
          plot_k_BA,
          plot_BA_H,
          ncol = 2)
sr_grid
```

```{r biplot_with_slopes}
var_ba_slope = var_ba_cwm_sr_df %>%
    ungroup() %>%
    filter(!is.nan(trait2_cwm)) %>%
    nest(-seed, -trait_cor, -k, -A,-B_over_A, -H, -R_scenar, -A_scenar,
         -H_scenar) %>%
    mutate(data = data %>%
               map(~.x %>%
                       gather("cwm_name", "cwm_value", ends_with("cwm")) %>%
                       filter(cwm_name == "trait2_cwm") %>%
                       group_by(cwm_name, add = TRUE) %>%
                       do(mod_cwm_env = lm(cwm_value ~ patch, data = .)) %>%
                       ungroup() %>%
                       mutate(mod_glance = lapply(mod_cwm_env, broom::tidy)) %>%
                       unnest(mod_glance))) %>%
    unnest(data) %>%
    filter(term == "patch")

plot_average_slope = function(var_df, x_var, y_var, given_labs = var_labs) {
    
    not_used_vars = setdiff(names(given_labs), c(x_var, y_var))
    
    var_df %>%
        ggplot(aes_string(x_var, y_var)) +
        stat_summary_2d(aes(z = estimate), fun = "mean", geom = "raster") +
        scale_fill_viridis_c(limits = c(0, 1)) +
        labs(x = var_labs[[x_var]],
             y = var_labs[[y_var]],
             fill = "CWM <-> Env. Slope",
             subtitle = paste0("Avg. R² over values of ",
                               paste(not_used_vars, collapse = " and "))) +
        theme(legend.position = "top",
              legend.text = element_text(angle = 45),
              aspect.ratio = 1)
}

# Plotting CWM <-> Env. Slope
plot_k_A_slope = plot_average_slope(var_ba_slope, "k", "A") +
    scale_y_log10()

plot_A_BA_slope = plot_average_slope(var_ba_slope, "A", "B_over_A") +
    scale_x_log10() +
    scale_y_log10()

plot_k_BA_slope = plot_average_slope(var_ba_slope, "k", "B_over_A") +
    scale_y_log10()

plot_k_H_slope = plot_average_slope(var_ba_slope, "k", "H")

plot_A_H_slope = plot_average_slope(var_ba_slope, "A", "H") +
    scale_x_log10()

plot_BA_H_slope = plot_average_slope(var_ba_slope, "B_over_A", "H") +
    scale_x_log10()

slope_grid = plot_grid(plot_k_A_slope,
          plot_k_H_slope,
          plot_A_BA_slope,
          plot_A_H_slope,
          plot_k_BA_slope,
          plot_BA_H_slope,
          nrow = 3)

slope_grid
```


```{r cwm_env_param}
var_ba_cwm_sr_df %>%
    filter(k %in% c(1.125, 1.5), H %in% c(0, 1, 2), A <= 1e-3, A >= 1e-5, B_over_A >= 10, B_over_A <= 1e4) %>%
    ggplot(aes(patch, trait2_cwm, color = as.factor(B_over_A))) +
    geom_abline(slope = 1, intercept = 0, linetype = 2) +
    geom_line(size = 1) +
    facet_grid(vars(A), vars(k, H), labeller = label_both) +
    scale_color_viridis_d() +
    labs(x = "Environment",
         y = "Trait 2 CWM",
         colour = "B/A") +
    theme(aspect.ratio = 1,
          legend.position = "top")
```

## Considering all scenarios to explore

If we want to be exhaustive in terms of scenario we can use the following:

```{r all_scenars}
# Simulation parameters = median parameters
fixed_A        = 1e-6
fixed_k        = 1.15
fixed_B_over_A = 100
fixed_H        = 1.25
n_seed         = 50

# Not fixed k
mean_k = 1.5
var_k  = 0.3
set.seed(20190129)
k_matrix = matrix(rnorm(n_species, mean_k, var_k))
rownames(k_matrix) = paste0("species", seq(n_species))
colnames(k_matrix) = "k"

# Generate all scenarios
weights = round(seq(0, 100, length.out = 3), digits = 0)

scenar_df = expand.grid(R = weights, A = weights, H = weights) %>%
    as_tibble() %>%
    mutate(scenar_name   = paste0("R", R, "A", A, "H", H),
           trait_weights = purrr::pmap(list(R, A, H),
                                       ~create_trait_weights(..1, ..2, ..3)))
scenar_list = scenar_df$trait_weights
names(scenar_list) = scenar_df$scenar_name

# Actual simulation
plan(multiprocess, workers = 15)
tictoc::tic()
var_scenars = list(seed     = seq(n_seed),
                   k        = k,
                   A        = fixed_A,
                   B_over_A = fixed_B_over_A,
                   H        = fixed_H,
                   h_fun    = "sum") %>%
    cross() %>%
    future_map(function(x){
        devtools::load_all()
        
        meta_simul_A_B_k_and_H(
            seed_number    = x$seed,
            given_k        = x$k,
            given_A        = x$A,
            given_B_over_A = x$B_over_A,
            given_H        = x$H,
            given_scenars  = scenar_list,
            given_h_fun    = x$h_fun)
    }, .progress = TRUE)
tictoc::toc()


used_trait_list = map(seq(n_seed), function(given_seed) {
    set.seed(given_seed)
    given_traits = generate_cor_traits(n_patches, n_species, n_traits - 1,
                                       cor_coef = 0)
    
    list(uncor = given_traits)
})

var_scenars_df = var_scenars %>%
    map2_dfr(used_trait_list, ~tidy_simulation_list(.x, .y, 150))

var_scenars_cwm = var_scenars_df %>%
    compute_site_cwm_cwv_sr()
```

```{r scenar_cwm}
plot_var_scenars_cwm = function(var_scenars_cwm) {
    
    param_caption = extract_caption(var_scenars_cwm)
    
    var_scenars_cwm %>%
        filter(patch >= 5, patch <= 20) %>%
        ggplot(aes(patch, trait2_cwm, color = as.factor(H_scenar),
                   # specify interaction otherwise it messes with groups
                   group = interaction(as.factor(H_scenar), seed))) +
        geom_abline(slope = 1, intercept = 0, linetype = 2) +
        geom_line(size = 1, alpha = 1/20) +
        geom_smooth(size = 1, method = "lm", se = FALSE, aes(group = NULL)) +
        ggpmisc::stat_poly_eq(aes(label = ..eq.label.., group = NULL),
                              formula = y ~ x, parse = TRUE, size = 3,
                              label.y.npc = "bottom", label.x.npc = "right") +
        facet_grid(vars(R_scenar), vars(A_scenar),
                   labeller = labeller(
                       R_scenar = function(x) paste0("Trait 2 Contrib.\n",
                                                     "to Growth : ", x, "%"),
                       A_scenar = function(x) paste0("Trait 2 Contrib.\nto ",
                                                     "Compet. : ", x, "%"))) +
        ylim(5, 20) +
        scale_color_manual(values = RColorBrewer::brewer.pal(7, "Purples")[5:7],
                           labels = function(x) paste0(x, "%")) +
        labs(x = "Environmental Variable",
             y = "CWM of Trait 2",
             color = "Trait 2 contrib. to Hierarch. Compet.",
             subtitle = expression("Trait 2 CWM <-> Environment (t"["opt"] *
                                       ") relationship"),
             caption = param_caption) +
        theme(aspect.ratio = 1,
              legend.position = "top")
}

plot_var_scenars_cwm(var_scenars_cwm)
```

We want to see the trait value of species in function of environment colored by local abundances with a line representing the CWM in function of the environment. Facets are different scenarios

```{r trait_abund_scenarios}
plot_trait_abund_scenarios = function(var_scenars_df) {
    
    param_caption = extract_caption(var_scenars_df)

    ggplot(var_scenars_df %>%
               filter(N > 0, patch >= 5, patch <= 20),
           aes(patch, trait2)) +
        stat_summary_2d(aes(z = N), geom = "raster", bins = 14,
                        interpolate = TRUE) +
        geom_line(data = var_scenars_cwm %>%
                      filter(patch >= 5, patch <= 20),
                  aes(y = trait2_cwm, color = "firebrick", group = seed),
                  size = 1, alpha = 1/10) +
        geom_smooth(data = var_scenars_cwm %>%
                      filter(patch >= 5, patch <= 20),
                    aes(y = trait2_cwm, color = "firebrick"),
                    size = 1, method = "lm", se = FALSE) +
        facet_grid(vars(R_scenar), vars(A_scenar, H_scenar),
                   labeller = label_both) +
        scale_fill_viridis_c(option = "E", trans = "sqrt") +
        scale_color_manual(name = "CWM", values = c(firebrick = "grey80"),
                           labels = "") +
        labs(x        = "Environment",
             y        = "Trait Value",
             fill     = "Species Abundance",
             subtitle = "Trait Environment and Abundance",
             caption  = param_caption) +
        guides(colour = guide_legend(override.aes = list(size = 1,
                                                         color = "grey50"))) +
        theme(legend.position = "top",
              aspect.ratio = 1)
}

plot_trait_abund_scenarios(var_scenars_df)
```

### Higher Initial population

We want to test the effect of initial conditions on patch dynamics.

```{r init_cond_patch_dynamics, eval = FALSE}
composition[,, "time1"] <- 500

plan(multiprocess, workers = 15)
tictoc::tic()

higher_init_pop = meta_simul_A_B_k_and_H(1,
                                         fixed_k,
                                         fixed_A,
                                         fixed_B_over_A,
                                         fixed_H_over_k,
                                         given_scenars = scenar_list) %>%
    map_dfr(as_tibble)

tictoc::toc()

higher_init_pop_df = higher_init_pop %>%
    mutate(patch1 = map(compo, function(x) {
        x["patches1",,] %>%
            as.data.frame() %>%
            rownames_to_column("species") %>%
            gather("timestep", "N", -species) %>%
            mutate(timestep = as.numeric(gsub("time", "", timestep)))
    }),
    patch13 = map(compo, function(x) {
        x["patches13",,] %>%
            as.data.frame() %>%
            rownames_to_column("species") %>%
            gather("timestep", "N", -species) %>%
            mutate(timestep = as.numeric(gsub("time", "", timestep)))
    }),
    patch25 = map(compo, function(x) {
        x["patches25",,] %>%
            as.data.frame() %>%
            rownames_to_column("species") %>%
            gather("timestep", "N", -species) %>%
            mutate(timestep = as.numeric(gsub("time", "", timestep)))
    }),
    R_scenar = as.numeric(gsub("R(\\d+)A\\d+H\\d+", "\\1", scenario, perl = TRUE)),
    A_scenar = as.numeric(gsub("R\\d+A(\\d+)H\\d+", "\\1", scenario, perl = TRUE)),
    H_scenar = as.numeric(gsub("R\\d+A\\d+H(\\d+)", "\\1", scenario, perl = TRUE)))

higher_init_pop_df  %>%
    unnest(patch1) %>%
    ggplot(aes(timestep, N, color = species)) +
    geom_line() +
    facet_grid(vars(R_scenar), vars(A_scenar, H_scenar), labeller = label_context) +
    labs(subtitle = paste0("Patch 1 Dynamics – ",
                           "A: ", fixed_A,
                           " ; k: ", fixed_k,
                           " ; B_over_A: ", fixed_B_over_A,
                           " ; H_over_k: ", fixed_H_over_k)) +
    theme(legend.position = "none")
```


## The fitness, optimality and abundance triangle

Here we want to investigate the link between abundance, fitness and optimality.
Now that we've done it for a single site we can try to generalize the process for all sites.

```{r all_sites_optimality}
given_compo = var_a_var_k_var_ba[[325]][[1]]

all_sp_data = extract_performances_from_simul(given_compo, used_traits$uncor)
```

```{r plot_patches, fig.width=7, fig.height=7}
plot_ab_growth_dist = all_sp_data %>%
    ggplot(aes(N150, max_growth_rate, color = distance_to_optimum)) +
    geom_point() +
    geom_smooth(method = "lm", se = FALSE) +
    ggpmisc::stat_poly_eq(formula = y ~ x, parse = TRUE) +
    ylim(NA, 1) +
    facet_wrap(~patch, labeller = label_both) +
    scale_color_viridis_c(option = "C") +
    labs(x     = "Abundance at time = 150",
         y     = "Maximum Growth Rate",
         color = "Distance to Optimum") +
    theme(legend.position = "top")
plot_ab_growth_dist


plot_ab_dist_growth = all_sp_data %>%
    ggplot(aes(N150, distance_to_optimum, color = max_growth_rate)) +
    geom_point() +
    geom_smooth(method = "lm", se = FALSE) +
    ggpmisc::stat_poly_eq(formula = y ~ x, parse = TRUE,
                          label.x.npc = "right") +
    facet_wrap(~patch, labeller = label_both) +
    scale_color_viridis_c(option = "C", limits = c(NA, 1)) +
    labs(x     = "Abundance at time = 150",
         y     = "Distance to Optimum",
         color = "Maximum Growth Rate") +
    theme(legend.position = "top")
plot_ab_dist_growth



plot_growth_dist_ab = all_sp_data %>%
    ggplot(aes(max_growth_rate, distance_to_optimum, color = N150)) +
    geom_point() +
    geom_smooth(method = "lm", se = FALSE) +
    ggpmisc::stat_poly_eq(formula = y ~ x, parse = TRUE,
                          label.x.npc = "right") +
    xlim(NA, 1) +
    facet_wrap(~patch, labeller = label_both) +
    scale_color_viridis_c(option = "C") +
    labs(x     = "Maximum Growth Rate",
         y     = "Distance to Optimum",
         color = "Abundance at time = 150") +
    theme(legend.position = "top")
plot_growth_dist_ab
```

### Showing the evolution of realized growth rates across patches

From a single simulation we can compute the realized growth rate. Then we can compare it across patches to see if certain patches exhibit specific dynamics.

```{r realized_growth_rate}
# Compute realized growth rates
real_gr = plyr::aaply(var_a_var_k_var_ba[[325]][[1]]$compo[[1]], 1,
                      function(species_time) {
    
  real_gr = (species_time[,-1] - species_time[, -ncol(species_time)]) /
               species_time[,-ncol(species_time)]
  
  return(real_gr)
})

real_gr_df = as.data.frame.table(real_gr) %>%
    rename(patch = X1, species = Var2, time = Var3, growth_rate = Freq) %>%
    mutate(time = as.numeric(gsub("time", "", time)))

plot_realized_growth_rate = ggplot(real_gr_df, aes(time, growth_rate,
                                                   color = species)) +
    geom_line() +
    facet_wrap(~patch) +
    labs(x = "Time", y = "Realized Growth Rate")
plot_realized_growth_rate
```


### Exploring the triangle across various trait scenarios (r = 0, r = -0.7, r = 0.7)

We want to explore the relationship between fitness, optimality and local abundance in function of trait scenarios (as well as different contributions)

```{r optimality_different_trait_corr}
# Simulation parameters
fixed_A = 1e-6
mean_k = 1.5
var_k  = 0.3
fixed_B_over_A = 100
fixed_H = 1

# Matrix of species maximum growth rates
set.seed(20190129)
k_matrix = matrix(rnorm(n_species, mean_k, var_k))
rownames(k_matrix) = paste0("species", seq(n_species))
colnames(k_matrix) = "k"

# Generate trait list
set.seed(1)
trait_list = list(
    uncor   = generate_cor_traits(n_patches, n_species, n_traits - 1,
                                  cor_coef = 0),
    negcor  = generate_cor_traits(n_patches, n_species, n_traits - 1,
                                  cor_coef = -0.7),
    highcor = generate_cor_traits(n_patches, n_species, n_traits - 1,
                                  cor_coef = 0.7)
)


# Actual simulation
tictoc::tic()
multi_traits_fixed = list(seed     = seq(1),
                          k        = list(k_matrix, mean_k),
                          A        = fixed_A,
                          B_over_A = fixed_B_over_A,
                          H        = fixed_H) %>%
    cross() %>%
    future_map(function(x){
        meta_simul_A_B_k_and_H(
            seed_number    = x$seed,
            given_k        = x$k,
            given_A        = x$A,
            given_B_over_A = x$B_over_A,
            given_H        = x$H,
            given_traits   = trait_list)
    }) %>%
    set_names(nm = c("gaussian", "fixed"))
tictoc::toc()

multi_traits_triangle = map_dfr(multi_traits_fixed, function(simul_given_k) {
    map2_dfr(simul_given_k, trait_list, extract_performances_from_simul)})
```

```{r plot_optimality_diff_trait_cor, fig.height=9.5}
fig_double_facet = function(given_df, x_var, y_var, col_var, given_labs,
                            given_label_pos = "left", trans_col = "identity") {
    given_df %>%
        filter(patch %in% seq(1, 25, by = 6)) %>%
    ggplot(aes_string(x_var, y_var, color = col_var)) +
        geom_hline(yintercept = 0, linetype = 2) +
        geom_point() +
        geom_smooth(method = "lm", se = FALSE) +
        ggpmisc::stat_poly_eq(formula = y ~ x, parse = TRUE,
                              aes(label = paste(..eq.label.., ..rr.label..,
                                            sep = "~~~")),
                              label.x.npc = given_label_pos, size = 3) +
        facet_grid(vars(patch), vars(k, trait_cor),
                   labeller = labeller(patch = label_both)) +
        labs(x     = given_labs[[x_var]],
             y     = given_labs[[y_var]],
             color = given_labs[[col_var]]) +
        scale_color_viridis_c(option = "C", trans = trans_col) +
        theme(legend.position = "top",
              strip.text = element_text(size = 8, margin = margin(1, 1, 1, 1)))
}

plot_multi_ab_growth_dist = fig_double_facet(
    multi_traits_triangle, "N150", "max_growth_rate", "distance_to_optimum",
    triangle_labs) +
    scale_y_sqrt()
plot_multi_ab_growth_dist

plot_multi_ab_dist_growth = fig_double_facet(
    multi_traits_triangle, "N150", "distance_to_optimum", "max_growth_rate",
    triangle_labs, "right")
plot_multi_ab_dist_growth

plot_multi_growth_dist_ab = fig_double_facet(
    multi_traits_triangle, "max_growth_rate", "distance_to_optimum", "N150",
    triangle_labs, "right") +
    scale_x_sqrt()
plot_multi_growth_dist_ab
```

```{r growth_and_other_performance_indinces}
plot_growth_rate_perf = multi_traits_triangle %>%
    gather("growth_rate_type", "growth_rate_value",
           ends_with("growth_rate")) %>%
    filter(patch %in% seq(1, 25, by = 6), growth_rate_value < 4,
           trait_cor == "uncor") %>%
    mutate(growth_rate_type = as_factor(growth_rate_type)) %>%
    gather("perf_type", "perf_value", N150, distance_to_optimum) %>%
    ggplot(aes(perf_value, growth_rate_value, color = growth_rate_type)) +
    geom_point(alpha = 1/6) +
    geom_smooth(method = "lm", se = FALSE) +
    ggpmisc::stat_poly_eq(formula = y ~ x, parse = TRUE, label.x.npc = "left",
                          aes(label = ..rr.label..), size = 3) +
    facet_grid(vars(k), vars(perf_type), scales = "free_x",
               labeller = labeller(
                   perf_type = c(
                       N150 = triangle_labs[["N150"]],
                       distance_to_optimum =
                           triangle_labs[["distance_to_optimum"]]),
                   k         = c(
                       "fixed = 1.5" = "k = 1.5",
                       gaussian = "k ~> N(1.5, 0.3)"))) +
    scale_color_brewer(
        labels = c(
            env_growth_rate = "Environmental Growth Rate\n (Growth only)",
            max_growth_rate = "Realized Growth Rate",
            th_growth_rate  = paste0("Theoretical Growth Rate\n",
                                     "(Growth + Hierarch. Compet.)")),
        palette = "Dark2") +
    labs(x = "Performance Value", y = "Growth Rate", color = NULL,
         subtitle = "Growth Rates Estimates vs. other Performance Indices",
         caption = paste0("No trait correlation; ",
                          "A = ", fixed_A,
                          "; B/A = ", fixed_B_over_A,
                          "; H = ", fixed_H)) +
    theme(legend.position = "top",
          panel.grid = element_blank(),
          aspect.ratio = 1)
plot_growth_rate_perf

plot_growth_rate_percapita_perf = multi_traits_triangle %>%
    gather("growth_rate_type", "growth_rate_value",
           ends_with("growth_rate_per_capita")) %>%
    filter(patch %in% seq(1, 25, by = 6), growth_rate_value < 4,
           trait_cor == "uncor") %>%
    mutate(growth_rate_type = as_factor(growth_rate_type)) %>%
    gather("perf_type", "perf_value", N150, distance_to_optimum) %>%
    ggplot(aes(perf_value, growth_rate_value, color = growth_rate_type)) +
    geom_point(alpha = 1/6) +
    geom_smooth(formula = y ~ log(x), se = FALSE) +
    ggpmisc::stat_poly_eq(formula = y ~ log(x), parse = TRUE,
                          label.x.npc = "left", aes(label = ..rr.label..),
                          size = 3) +
    facet_grid(vars(k), vars(perf_type), scales = "free_x",
               labeller = labeller(
                   perf_type = c(
                       N150 = triangle_labs[["N150"]],
                       distance_to_optimum =
                           triangle_labs[["distance_to_optimum"]]),
                   k         = c(
                       "fixed = 1.5" = "k = 1.5",
                       gaussian = "k ~> N(1.5, 0.3)"))) +
    scale_color_brewer(
        labels = c(
            env_growth_rate_per_capita = paste0("Env. Growth Rate per Capita\n",
                                                "(Growth only)"),
            max_growth_rate_per_capita = "Realized Growth Rate\nper Capita",
            th_growth_rate_per_capita  = paste0("Theoretical Growth Rate\n",
                                                "per Capita \n(Growth + ",
                                                "Hierarch. Compet.)")),
        palette = "Set2") +
    scale_y_log10() +
    labs(x = "Performance Value", y = "Growth Rate per Capita", color = NULL,
         subtitle = "Growth Rates per Capita vs. other Performance Indices",
         caption = paste0("No trait correlation; ",
                          "A = ", fixed_A,
                          "; B/A = ", fixed_B_over_A,
                          "; H = ", fixed_H)) +
    theme(legend.position = "top",
          panel.grid = element_blank(),
          aspect.ratio = 1)
plot_growth_rate_percapita_perf
```

```{r testing_more_parameters}
# Simulation parameters
fixed_A = 10^seq(-6, -2)
mean_k = 1.5
var_k  = 0.3
fixed_B_over_A = 10^seq(1, 3)
fixed_H = c(0, 1, 2)

# Matrix of species maximum growth rates
set.seed(20190129)
k_matrix = matrix(rnorm(n_species, mean_k, var_k))
rownames(k_matrix) = paste0("species", seq(n_species))
colnames(k_matrix) = "k"

# Generate trait list
set.seed(1)
trait_list = list(
    uncor   = generate_cor_traits(n_patches, n_species, n_traits - 1,
                                  cor_coef = 0),
    negcor  = generate_cor_traits(n_patches, n_species, n_traits - 1,
                                  cor_coef = -0.7),
    highcor = generate_cor_traits(n_patches, n_species, n_traits - 1,
                                  cor_coef = 0.7)
)

plan(multiprocess, workers = 15)
# Actual simulation
tictoc::tic()
var_param = list(seed     = seq(1),
                 k        = list(k_matrix, mean_k),
                 A        = fixed_A,
                 B_over_A = fixed_B_over_A,
                 H        = fixed_H) %>%
    cross() %>%
    future_map(function(x){
        devtools::load_all()
        meta_simul_A_B_k_and_H(
            seed_number    = x$seed,
            given_k        = x$k,
            given_A        = x$A,
            given_B_over_A = x$B_over_A,
            given_H        = x$H,
            given_traits   = trait_list)
    }, .progress = TRUE)
tictoc::toc()

tictoc::tic()
var_param_triangle = map_dfr(var_param, function(simul_given_k) {
    map2_dfr(simul_given_k, trait_list, extract_performances_from_simul,
             compute_realized_growth_rate = FALSE)})
tictoc::toc()

var_param_triangle %>%
    filter(trait_cor == "uncor", H != 1, B_over_A == 100, A <= 1e-4, N150 > 0) %>%
    ggplot(aes(distance_to_optimum, N150, color = k)) +
    geom_point(shape = ".") +
    geom_smooth(method = "lm", se = FALSE) +
    ggpmisc::stat_poly_eq(formula = y ~ x, parse = TRUE, label.x.npc = "right",
                          aes(label = ..rr.label..), size = 3) +
    facet_grid(vars(A), vars(H, B_over_A), labeller = label_both) +
    theme(aspect.ratio = 1) +
    labs(x = triangle_labs[["distance_to_optimum"]],
         y = triangle_labs[["N150"]],
         subtitle = "Abundance ~ Optimality with various parameters",
         caption = "No trait correlation; k ~~> N(1.5, 0.3)")

var_param_triangle %>%
    filter(trait_cor == "uncor", H != 1, B_over_A == 100, A <= 1e-4, N150 > 0) %>%
    ggplot(aes(N150, env_growth_rate)) +
    geom_point(alpha = 1/6) +
    geom_smooth(method = "lm", se = FALSE) +
    ggpmisc::stat_poly_eq(formula = y ~ x, parse = TRUE, label.x.npc = "right",
                          aes(label = ..rr.label..), size = 3) +
    facet_grid(vars(A), vars(k, H, B_over_A)) +
    scale_x_log10()
```


## Testing a way bigger species pool

To avoid functional truncation effect we can make our simulation with a much bigger species pool.

```{r much_bigger_species_pool}
# Simulation parameters
fixed_A = 1e-6
fixed_k = 1.5
fixed_B_over_A = 100
fixed_H = 0.5

# Generate species pool
max_value   =  75
big_species = 500
min_value   = -50
n_seed = 20
big_trait_list = map(seq(n_seed), function(given_seed) {
    set.seed(given_seed)
    given_traits = generate_cor_traits(max_value, big_species, n_traits - 1,
                                       cor_coef = 0, min_value)
    
    list(uncor = given_traits)
})

# Initial composition
composition <- array(NA, dim = c(n_patches, big_species, n_gen),
                     dimnames = list(paste0("patches", seq(n_patches)),
                                     paste0("species", seq(big_species)),
                                     paste0("time", seq(n_gen))))
composition[,,"time1"] <- 50


plan(multiprocess, workers = 15)
# Actual simulation
tictoc::tic()
big_species_simul = list(seed     = seq(n_seed),
                         k        = fixed_k,
                         A        = fixed_A,
                         B_over_A = fixed_B_over_A,
                         H        = fixed_H) %>%
    cross() %>%
    future_map(function(x){
        devtools::load_all()
        meta_simul_A_B_k_and_H(
            seed_number    = x$seed,
            given_k        = x$k,
            given_A        = x$A,
            given_B_over_A = x$B_over_A,
            given_H        = x$H,
            given_traits   = big_trait_list[[x$seed]])
    }, .progress = TRUE)
tictoc::toc()

big_species_df = map2_dfr(big_species_simul, big_trait_list,
                          ~tidy_simulation_list(.x, .y, 150))

big_species_cwm = compute_site_cwm_cwv_sr(big_species_df)
```
