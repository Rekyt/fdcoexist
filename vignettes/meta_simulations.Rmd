---
title: "fdcoexist simulate with various parameters and traits"
author:
    - Pierre Denelle, Matthias Grenié, Cyrille Violle, François Munoz and Caroline M. Tucker
date: "`r format(Sys.time(), '%d %B %Y')`"
output: pdf_document
vignette: >
  %\VignetteIndexEntry{Full equation of the model}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
editor_options: 
  chunk_output_type: console
---

```{r setup, echo=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE,
                      fig.width = 8, fig.height = 10.5, cache = TRUE)

# Packages ---------------------------------------------------------------------
suppressPackageStartupMessages({
    suppressWarnings({
        library("cowplot")
        library("tidyr")
        library("dplyr")
        library("purrr")
        library("forcats")
        library("ggplot2")
        library("stringr")
        library("tibble")
        library("directlabels")
        library("furrr")
    })
})

plan(sequential)
# Functions --------------------------------------------------------------------
# Compute a data.frame of number of individuals in function of optimal trait
# for competition and growth
landscape_df = function(multiple_traits_scenario, trait_df, trait_weights,
                        time = 150) {
    
    growth_traits = subset(trait_weights, growth_weight != 0)$trait
    compet_traits = subset(trait_weights, compet_weight != 0)$trait
    
    
    population_df = multiple_traits_scenario$compo[[1]][,,time] %>%
        as.data.frame() %>%
        rownames_to_column("patch") %>%  # Add patch names as column
        # Transform to tidy data.frame (define name of columns and column name
        # for values)
        gather("species", "N", -patch)
    
    growth_df = enframe(rowMeans(trait_df[, growth_traits, drop = FALSE]),
                        "species", "growth_trait")
    
    compet_df = enframe(abs(rowMeans(trait_df[, compet_traits, drop = FALSE]) -
                                12.5), "species", "compet_dist")
    
    population_df %>%
        inner_join(growth_df, by = "species") %>%
        inner_join(compet_df, by = "species") %>%
        # Add patch number as a new column and compute distance to optimal value
        mutate(patch_optim = gsub("patches", "", patch) %>%
                   as.numeric(),
               optim_dist = abs(growth_trait - patch_optim))
}

# This function tidy a list of simulation routine to a single data.frame
# suitable to make figures.
tidy_simulation_list = function(simulation_list, set_of_traits, trait_scenarios,
                                time = 150, scenar_names = names(trait_scenarios)) {
    simulation_list %>%
        names() %>%
        # Tidy single simulations
        lapply(tidy_simulation,
               given_simul = simulation_list,
               given_traits = set_of_traits,
               given_trait_scenar = trait_scenarios,
               time = time) %>%
        # Re-add names
        set_names(nm = names(simulation_list)) %>%
        # Join into single data.frame
        bind_rows(.id = "scenario") %>%
        # Compute pre-CWMs
        mutate_at(vars(contains("trait")), funs(cwm = rel_abund * .)) %>%
        mutate(scenario = fct_relevel(scenario, scenar_names))
}

tidy_simulation = function(scenario, given_simul, given_traits,
                           given_trait_scenar, time = 150) {
    landscape_df(given_simul[[scenario]], given_traits,
                 trait_scenarios[[scenario]], time = time) %>%
        inner_join(given_traits %>%
                       as.data.frame() %>%
                       rownames_to_column("species"),
                   by = "species") %>%
        group_by(patch) %>%
        mutate(rel_abund = N/sum(N)) %>%
        ungroup()
}
# Initial parameters -----------------------------------------------------------
suppressMessages(devtools::load_all())

n_patches <- 25   # Number of patches
n_species <- 100  # Number of species
n_gen     <- 150  # Length of model run (generations)
initpop   <- 50   # initial population size
n_traits  <- 4    # number of traits
k         <- 1.15 # Maximum growth rate
env_width <- rep(10, length.out = n_patches)  # Envtal filter strength
var_width <- seq(10, 1, length.out = n_patches) # Varying envtal filter strength
total_runs = 20  # Number of set of traits to test

# Competition + Dispersion coefficients
B = 2e-4       # Scalar for intraspecific competition
A = 2e-4       # Alpha scalar
d = 0.05       # Dispersal percentage
dist_power = 2 # Power of trait dissimilarity

# Hierarchical coefficients
H = 1.01
th_max = 25

# Generate environment
env <- seq(n_patches)

# Array for simulations
composition <- array(NA, dim = c(n_patches, n_species, n_gen),
                     dimnames = list(paste0("patches", seq(n_patches)),
                                     paste0("species", seq(n_species)),
                                     paste0("time", seq(n_gen))))
names(env) <- dimnames(composition)[[1]]

composition[,, "time1"] <- initpop

# Define scenarios -------------------------------------------------------------
# Scenarios on traits affecting growth and competition
trait_scenarios = c("R0A0", "R0A100", "R10A90", "R25A75", "R50A50", "R75A25",
                    "R90A10", "R100A0", "R100A100")

names(trait_scenarios) = trait_scenarios

trait_scenarios = lapply(trait_scenarios, function(scenar_name) {
    growth = as.numeric(gsub("R(\\d+)A\\d+", "\\1", scenar_name, perl = TRUE))
    compet = as.numeric(gsub("R\\d+A(\\d+)", "\\1", scenar_name, perl = TRUE))
    
    create_trait_weights(growth, compet, 0)
})

# Define meta-function to run all analyses with many trait levels --------------

meta_simul = function(seed_number, given_k = k, given_A = A) {
    set.seed(seed_number)
    uncor_traits = generate_cor_traits(n_patches, n_species, n_traits - 1,
                                       cor_coef = 0)
    set.seed(seed_number)
    low_cor_traits = generate_cor_traits(n_patches, n_species, n_traits - 1,
                                         cor_coef = 0.3)
    
    set.seed(seed_number)
    high_cor_traits = generate_cor_traits(n_patches, n_species, n_traits - 1,
                                          cor_coef = 0.7)
    all_cor = list(uncor    = uncor_traits,
                   low_cor  = low_cor_traits,
                   high_cor = high_cor_traits)
    
    all_env = list(constant          = env_width,
                   constant_strong   = env_width/2,
                   constant_stronger = env_width/5,
                   varying           = var_width)
    
    all_compet = list(no_compet = list(A = 0, B = B),
                      compet    = list(A = given_A, B = B))
    
    all_facets = expand.grid(compet_status = names(all_compet),
                             env_width     = names(all_env),
                             cor_level     = names(all_cor),
                             scenario      = names(trait_scenarios))
    
    apply(all_facets, 1, function(given_row) {
        multigen(traits = all_cor[[given_row[["cor_level"]]]],
                 trait_weights = trait_scenarios[[given_row[["scenario"]]]],
                 env = env,
                 time = n_gen,
                 species = n_species,
                 patches = n_patches,
                 composition = composition,
                 A = all_compet[[given_row[["compet_status"]]]][["A"]],
                 B = all_compet[[given_row[["compet_status"]]]][["B"]],
                 d = d,
                 k = given_k,
                 dist_power = dist_power,
                 H = H, th_max = th_max,
                 width = all_env[[given_row[["env_width"]]]]) %>%
            landscape_df(all_cor[[given_row[["cor_level"]]]],
                         trait_scenarios[[given_row[["scenario"]]]],
                         time = 150) %>%
            inner_join(all_cor[[given_row[["cor_level"]]]] %>%
                           as.data.frame() %>%
                           rownames_to_column("species"),
                       by = "species") %>%
            group_by(patch) %>%
            mutate(rel_abund = N/sum(N)) %>%
            ungroup() %>%
            mutate(compet_status = given_row[["compet_status"]],
                   env_width     = given_row[["env_width"]],
                   cor_level     = given_row[["cor_level"]],
                   scenario      = given_row[["scenario"]],
                   seed_number = seed_number) %>%
            select(seed_number, compet_status, env_width, cor_level, scenario,
                   everything())
    }) %>%
        bind_rows() %>%
        filter(N != 0) %>%  # Take out absent species
        mutate_at(vars(contains("trait")), funs(cwm = rel_abund * .)) %>%
        mutate(scenario = fct_relevel(scenario, names(trait_scenarios)),
               patch_optim = as.numeric(gsub("patches", "", patch))) %>%
        group_by(seed_number, compet_status, env_width, cor_level, scenario,
                 patch) %>%
        summarise(trait1_cwm  = sum(trait1_cwm),
                  trait2_cwm  = sum(trait2_cwm),
                  trait3_cwm  = sum(trait3_cwm),
                  trait1_var  = var(trait1),
                  trait2_var  = var(trait2),
                  trait3_var  = var(trait3),
                  patch_optim = unique(patch_optim))
}

meta_simul2 = function(seed_number, given_k = k, given_A = A) {
    set.seed(seed_number)
    uncor_traits = generate_cor_traits(n_patches, n_species, n_traits - 1,
                                       cor_coef = 0)

    all_cor = list(uncor  = uncor_traits)
    
    all_env = list(constant = env_width)
    
    all_compet = list(compet = list(A = given_A, B = B))
    
    all_facets = expand.grid(compet_status = names(all_compet),
                             env_width     = names(all_env),
                             cor_level     = names(all_cor),
                             scenario      = names(trait_scenarios))
    
    apply(all_facets, 1, function(given_row) {
        multigen(traits = all_cor[[given_row[["cor_level"]]]],
                 trait_weights = trait_scenarios[[given_row[["scenario"]]]],
                 env = env,
                 time = n_gen,
                 species = n_species,
                 patches = n_patches,
                 composition = composition,
                 A = all_compet[[given_row[["compet_status"]]]][["A"]],
                 B = all_compet[[given_row[["compet_status"]]]][["B"]],
                 d = d,
                 k = given_k,
                 dist_power = dist_power,
                 H = H, th_max = th_max,
                 width = all_env[[given_row[["env_width"]]]]) %>%
            landscape_df(all_cor[[given_row[["cor_level"]]]],
                         trait_scenarios[[given_row[["scenario"]]]],
                         time = 150) %>%
            inner_join(all_cor[[given_row[["cor_level"]]]] %>%
                           as.data.frame() %>%
                           rownames_to_column("species"),
                       by = "species") %>%
            group_by(patch) %>%
            mutate(rel_abund = N/sum(N)) %>%
            ungroup() %>%
            mutate(compet_status = given_row[["compet_status"]],
                   env_width     = given_row[["env_width"]],
                   cor_level     = given_row[["cor_level"]],
                   scenario      = given_row[["scenario"]],
                   seed_number = seed_number) %>%
            select(seed_number, compet_status, env_width, cor_level, scenario,
                   everything())
    }) %>%
        bind_rows() %>%
        filter(N != 0) %>%  # Take out absent species
        mutate_at(vars(contains("trait")), funs(cwm = rel_abund * .)) %>%
        mutate(scenario = fct_relevel(scenario, names(trait_scenarios)),
               patch_optim = as.numeric(gsub("patches", "", patch))) %>%
        group_by(seed_number, compet_status, env_width, cor_level, scenario,
                 patch) %>%
        summarise(trait1_cwm  = sum(trait1_cwm),
                  trait2_cwm  = sum(trait2_cwm),
                  trait3_cwm  = sum(trait3_cwm),
                  trait1_var  = var(trait1),
                  trait2_var  = var(trait2),
                  trait3_var  = var(trait3),
                  patch_optim = unique(patch_optim))
}

meta_simul_patch = function(seed_number, given_k = k, given_A = A) {
    set.seed(seed_number)
    uncor_traits = generate_cor_traits(n_patches, n_species, n_traits - 1,
                                       cor_coef = 0)
    
    all_cor = list(uncor    = uncor_traits)
    
    all_env = list(constant          = env_width)
    
    all_compet = list(compet    = list(A = given_A, B = B))
    
    all_facets = expand.grid(compet_status = names(all_compet),
                             env_width     = names(all_env),
                             cor_level     = names(all_cor),
                             scenario      = names(trait_scenarios))
    
    all_simuls = apply(all_facets, 1, function(given_row) {
        multigen(traits = all_cor[[given_row[["cor_level"]]]],
                 trait_weights = trait_scenarios[[given_row[["scenario"]]]],
                 env = env,
                 time = n_gen,
                 species = n_species,
                 patches = n_patches,
                 composition = composition,
                 A = all_compet[[given_row[["compet_status"]]]][["A"]],
                 B = all_compet[[given_row[["compet_status"]]]][["B"]],
                 d = d,
                 k = given_k,
                 width = all_env[[given_row[["env_width"]]]])
    })
    
    list(simul = all_simuls, trait = uncor_traits)
}

meta_simul_A_B_k_and_H = function(seed_number, given_k = k, given_A = A,
                                  given_B_over_A = B/A,
                                  given_H = H, given_scenars = NULL,
                                  given_traits = NULL) {
    
    our_scenars = list(R50A50H50 = create_trait_weights(50, 50, 50))
    
    if (!is.null(given_scenars)) {
        our_scenars = given_scenars
    }
    
    set.seed(seed_number)
    uncor_traits = generate_cor_traits(n_patches, n_species, n_traits - 1,
                                       cor_coef = 0)
    all_cor = list(uncor = uncor_traits)
    
    if (!is.null(given_traits)) {
        all_cor = given_traits
    }
    
    all_env = list(constant = env_width)
    
    all_compet = list(compet = list(A        = given_A,
                                    B        = given_A * given_B_over_A,
                                    H        = given_H,
                                    B_over_A = given_B_over_A))

    
    all_facets = expand.grid(compet_status = names(all_compet),
                             env_width     = names(all_env),
                             cor_level     = names(all_cor),
                             scenario      = names(our_scenars))
    
    apply(all_facets, 1, function(given_row) {
        simul = multigen(traits = all_cor[[given_row[["cor_level"]]]],
                 trait_weights = our_scenars[[given_row[["scenario"]]]],
                 env = env,
                 time = n_gen,
                 species = n_species,
                 patches = n_patches,
                 composition = composition,
                 A = all_compet[[given_row[["compet_status"]]]][["A"]],
                 B = all_compet[[given_row[["compet_status"]]]][["B"]],
                 d = d,
                 k = given_k,
                 dist_power = dist_power,
                 H = all_compet[[given_row[["compet_status"]]]][["H"]],
                 th_max = th_max,
                 width = all_env[[given_row[["env_width"]]]])
        
        return(
            list(
                k             = given_k,
                A             = all_compet[[given_row[["compet_status"]]]][["A"]],
                B_over_A      = all_compet[[given_row[["compet_status"]]]][["B_over_A"]],
                H             = all_compet[[given_row[["compet_status"]]]][["H"]],
                seed          = seed_number,
                compet_status = given_row[["compet_status"]],
                env           = given_row[["env_width"]],
                traits        = given_row[["cor_level"]],
                scenario      = given_row[["scenario"]],
                compo         = list(simul$compo),
                rmatrix       = simul$rmatrix,
                rmatenv       = simul$rmatenv))
    })
}
# Generate traits --------------------------------------------------------------
trait_seed = 5
# Make traits with different correlations
set.seed(trait_seed)
uncor_traits = generate_cor_traits(n_patches, n_species, n_traits - 1,
                                   cor_coef = 0)
set.seed(trait_seed)
low_cor_traits = generate_cor_traits(n_patches, n_species, n_traits - 1,
                                     cor_coef = 0.3)

set.seed(trait_seed)
high_cor_traits = generate_cor_traits(n_patches, n_species, n_traits - 1,
                                      cor_coef = 0.7)


# Graphical parameters ---------------------------------------------------------
theme_set(theme_bw(12))

# Graphical functions ----------------------------------------------------------
label_scenar_facets = function(scenar_name) {
    scenar_name %>%
        as.character() %>%
        str_remove("R") %>%
        str_split("A") %>%
        map_chr(~paste0("Growth = ",  .x[1], "%\n",
                        "Compet. = ", .x[2], "%"))
}

facet_scenar = facet_wrap(vars(scenario),
                          labeller = labeller(scenario = label_scenar_facets))

lab_compet_env = labeller(
    compet_status = c(compet    = "Intra + Inter competition",
                      no_compet = "Intra Only"),
    env_width     = c(constant          = "Constant\nWide Env. Filter",
                      constant_strong   = "Constant\nStrong Env. Filter",
                      constant_stronger = "Constant\nVery Strong Env. Filter",
                      varying           = "Increasing\nFilter Strength"))

lab_cor = c(uncor    = "r = 0",
            low_cor  = "r = 0.3",
            high_cor = "r = 0.7")

```

```{r looking_at_slopes, eval = FALSE}
list_A = 2*10^-(seq(4, 6))
list_k = 1 + c(0.05, 0.15, 0.25)

plan(multiprocess, workers = 15)
tictoc::tic()

var_k_var_a = cross(list(run_n = seq(total_runs), A = list_A, k = list_k)) %>%
    future_map(function(x) {
    devtools::load_all()
    
    meta_simul2(x$run_n, x$k, x$A) %>%
        mutate(k = x$k, A = x$A)
}, .progress = TRUE)
tictoc::toc()

var_k_var_a_cwm = var_k_var_a %>%
    bind_rows() %>%
    ungroup() %>%
    nest(-k, -A, -seed_number, -scenario) %>%
    mutate(data = data %>%
               map(~.x %>%
                       gather("cwm_name", "cwm_value", ends_with("cwm")) %>%
                       group_by(cwm_name, add = TRUE) %>%
                       do(mod_cwm_env = lm(cwm_value ~ patch_optim, data = .)) %>%
                       ungroup() %>%
                       mutate(mod_glance = lapply(mod_cwm_env, broom::tidy)) %>%
                       unnest(mod_glance))) %>%
    unnest(data) %>%
    filter(cwm_name == "trait2_cwm")
```

We want to follow the dynamics through time to understand the variation in Rsquare
```{r time_dynamics, eval = FALSE}
patch_k_run_char = paste0("N = ", total_runs, "; A = ", A, "; B = ", B, "; k = ",
                        k)

plan(multiprocess, workers = 15)
tictoc::tic()

patch_k_simuls = future_map(seq(total_runs), function(x) {
    devtools::load_all()
    
    meta_simul_patch(x, )
}, .progress = TRUE)
tictoc::toc()

patch_k_simuls[[1]][[1]][[1]]$compo[15,,] %>%
    as.data.frame() %>%
    rownames_to_column("species") %>%
    gather("time", "N", -species) %>%
    group_by(time) %>%
    mutate(tot_abund = sum(N)) %>%
    ungroup() %>%
    mutate(rel_abund = N / tot_abund) %>%
    inner_join(patch_k_simuls[[1]]$trait %>%
                   as.data.frame() %>%
                   rownames_to_column("species"),
               by = "species") %>%
    mutate_at(vars(starts_with("trait")), funs(precwm = rel_abund * .)) %>%
    group_by(time) %>%
    summarise_at(vars(ends_with("cwm")), sum) %>%
    mutate(time = as.numeric(gsub("time", "", time))) %>%
    gather("cwm_name", "cwm_value", contains("precwm")) %>%
    ggplot(aes(time, cwm_value)) +
    geom_line() +
    facet_grid(cols = vars(cwm_name))
```


## Coexistence plot depending on A, B/A and k


```{r param_space_simuls}
list_A = 10^-(seq(2, 6, length.out = 5))
list_k = seq(1, 1.5, length.out = 5)
list_B_over_A = 10^seq(0, 4, length.out = 5)
list_H_over_k = seq(0, 2, length.out = 5)

plan(multiprocess, workers = 15)
tictoc::tic()

var_a_var_k_var_ba = cross(list(run_n = seq(1), A = list_A, k = list_k,
                         B_over_A = list_B_over_A,
                         H_over_k = list_H_over_k)) %>%
    future_map(function(x) {
    devtools::load_all()
    
    meta_simul_A_B_k_and_H(x$run_n, x$k, x$A, x$B_over_A,
                           given_H_over_k = x$H_over_k)
}, .progress = TRUE)
tictoc::toc()

set.seed(1)
used_traits = generate_cor_traits(n_patches, n_species, n_traits - 1,
                                  cor_coef = 0)

single_scenario = list(R50A50H50 = create_trait_weights(50, 50, 50))


var_ba_df = lapply(var_a_var_k_var_ba, function(x) {
    x[[1]] %>%
            landscape_df(used_traits,
                         single_scenario[[1]],
                         time = 150) %>%
            inner_join(used_traits %>%
                           as.data.frame() %>%
                           rownames_to_column("species"),
                       by = "species") %>%
            group_by(patch) %>%
            mutate(rel_abund = N/sum(N)) %>%
            ungroup() %>%
            mutate(k             = x[[1]]$k,
                   A             = x[[1]]$A,
                   B_over_A      = x[[1]]$B_over_A,
                   H_over_k      = x[[1]]$H_over_k,
                   compet_status = "compet",
                   env_width     = "constant",
                   cor_level     = "uncor",
                   scenario      = names(single_scenario),
                   seed_number   = 1) %>%
            select(k, A, B_over_A, H_over_k, seed_number, compet_status,
                   env_width, cor_level, scenario, everything())
}) %>%
        bind_rows() %>%
        mutate_at(vars(contains("trait")), funs(cwm = rel_abund * .)) %>%
        mutate(patch_optim = as.numeric(gsub("patches", "", patch))) %>%
        group_by(k, A, B_over_A, H_over_k, seed_number, compet_status,
                 env_width, cor_level, scenario, patch) %>%
        summarise(species_rich = sum(N > 0),
                  trait1_cwm   = sum(trait1_cwm),
                  trait2_cwm   = sum(trait2_cwm),
                  trait3_cwm   = sum(trait3_cwm),
                  trait1_var   = var(trait1),
                  trait2_var   = var(trait2),
                  trait3_var   = var(trait3),
                  patch_optim  = unique(patch_optim))

var_labs = c(k        = "k (maximum growth rate)",
             A        = "A (interspecific competition)",
             B_over_A   = "B/A (ratio intra/inter)",
             H_over_k = "H/k (ratio hierarch./max. growth)")
```

```{r interactive_species_rich_plot, eval = FALSE}
library("plotly")

var_ba_df %>%
    filter(patch == "patches13", species_rich > 0) %>%
    plot_ly(x = ~k, y = ~A, z = ~B_over_A, color = ~species_rich,
            text = ~paste("SR: ", species_rich)) %>%
    add_markers() %>%
    layout(scene = list(xaxis = list(title = ),
                        yaxis = list(title = 'A (interspecific competition)',
                                     type = "log"),
                        zaxis = list(title = 'B/A (ratio intra/inter)',
                                     type = "log")))
```

```{r biplot_of_parameters_richness}
plot_species_richness = function(var_df, x_var, y_var, given_labs = var_labs) {
    
    not_used_vars = setdiff(names(given_labs), c(x_var, y_var))
    
    var_df %>%
        ggplot(aes_string(x_var, y_var)) +
        stat_summary_2d(aes(z = species_rich), fun = "mean", geom = "raster") +
        facet_wrap(~patch) +
        scale_fill_viridis_c(limits = c(0, 100)) +
        labs(x = var_labs[[x_var]],
             y = var_labs[[y_var]],
             fill = "Species Richness\n(at t = 150)",
             subtitle = paste0("Avg. SR over values of ",
                               paste(not_used_vars, collapse = " and "))) +
        theme(legend.position = "top",
              legend.text = element_text(angle = 45))
}

plot_k_A = var_ba_df %>%
    filter(patch %in% paste0("patches", c(1, 13))) %>%
    plot_species_richness("k", "A") +
    scale_y_log10()

plot_A_BA = var_ba_df %>%
    filter(patch %in% paste0("patches", c(1, 13))) %>%
    plot_species_richness("A", "B_over_A") +
    scale_x_log10() +
    scale_y_log10()

plot_k_BA = var_ba_df %>%
    filter(patch %in% paste0("patches", c(1, 13))) %>%
    plot_species_richness("k", "B_over_A") +
    scale_y_log10()

plot_k_Hk = var_ba_df %>%
    filter(patch %in% paste0("patches", c(1, 13))) %>%
    plot_species_richness("k", "H_over_k")

plot_A_Hk = var_ba_df %>%
    filter(patch %in% paste0("patches", c(1, 13))) %>%
    plot_species_richness("A", "H_over_k") +
    scale_x_log10()

plot_BA_Hk = var_ba_df %>%
    filter(patch %in% paste0("patches", c(1, 13))) %>%
    plot_species_richness("B_over_A", "H_over_k") +
    scale_x_log10()

sr_grid = plot_grid(plot_k_A,
          plot_k_Hk,
          plot_A_BA,
          plot_A_Hk,
          plot_k_BA,
          plot_BA_Hk,
          ncol = 2)
sr_grid
```

```{r biplot_with_R2}
var_ba_r2 = var_ba_df %>%
    ungroup() %>%
    filter(!is.nan(trait2_cwm)) %>%
    nest(-k, -A,-B_over_A, -H_over_k, -seed_number, -scenario) %>%
    mutate(data = data %>%
               map(~.x %>%
                       gather("cwm_name", "cwm_value", ends_with("cwm")) %>%
                       group_by(cwm_name, add = TRUE) %>%
                       do(mod_cwm_env = lm(cwm_value ~ patch_optim, data = .)) %>%
                       ungroup() %>%
                       mutate(mod_glance = lapply(mod_cwm_env, broom::glance)) %>%
                       unnest(mod_glance))) %>%
    unnest(data) %>%
    filter(cwm_name == "trait2_cwm")

# function to plot R² of CWM <-> Env relationship
plot_average_r_squared = function(var_df, x_var, y_var, given_labs = var_labs) {
    
    not_used_vars = setdiff(names(given_labs), c(x_var, y_var))
    
    var_df %>%
        ggplot(aes_string(x_var, y_var)) +
    stat_summary_2d(aes(z = adj.r.squared), fun = "mean", geom = "raster") +
    scale_fill_viridis_c(limits = c(0, 1)) +
    labs(x = var_labs[[x_var]],
         y = var_labs[[y_var]],
         fill = "CWM <-> Env. R^2",
         subtitle = paste0("Avg. R² over values of ",
                           paste(not_used_vars, collapse = " and "))) +
    theme(legend.position = "top",
          legend.text = element_text(angle = 45))
}



# Plotting R-squared
plot_k_A_r2 = plot_average_r_squared(var_ba_r2, "k", "A") +
    scale_y_log10()

plot_A_BA_r2 = plot_average_r_squared(var_ba_r2, "A", "B_over_A") +
    scale_x_log10() +
    scale_y_log10()

plot_k_BA_r2 = plot_average_r_squared(var_ba_r2, "k", "B_over_A") +
    scale_y_log10()

plot_k_Hk_r2 = plot_average_r_squared(var_ba_r2, "k", "H_over_k")

plot_A_Hk_r2 = plot_average_r_squared(var_ba_r2, "A", "H_over_k") +
    scale_x_log10()

plot_BA_Hk_r2 = plot_average_r_squared(var_ba_r2, "B_over_A", "H_over_k") +
    scale_x_log10()

r2_grid = plot_grid(plot_k_A_r2,
          plot_k_Hk_r2,
          plot_A_BA_r2,
          plot_A_Hk_r2,
          plot_k_BA_r2,
          plot_BA_Hk_r2,
          ncol = 2)

r2_grid
```

```{r biplot_with_slopes}
var_ba_slope = var_ba_df %>%
    ungroup() %>%
    filter(!is.nan(trait2_cwm)) %>%
    nest(-k, -A,-B_over_A, -H_over_k, -seed_number, -scenario) %>%
    mutate(data = data %>%
               map(~.x %>%
                       gather("cwm_name", "cwm_value", ends_with("cwm")) %>%
                       group_by(cwm_name, add = TRUE) %>%
                       do(mod_cwm_env = lm(cwm_value ~ patch_optim, data = .)) %>%
                       ungroup() %>%
                       mutate(mod_glance = lapply(mod_cwm_env, broom::tidy)) %>%
                       unnest(mod_glance))) %>%
    unnest(data) %>%
    filter(cwm_name == "trait2_cwm") %>%
    filter(term == "patch_optim")

plot_average_slope = function(var_df, x_var, y_var, given_labs = var_labs) {
    
    not_used_vars = setdiff(names(given_labs), c(x_var, y_var))
    
    var_df %>%
        ggplot(aes_string(x_var, y_var)) +
        stat_summary_2d(aes(z = estimate), fun = "mean", geom = "raster") +
        scale_fill_viridis_c(limits = c(0, 1)) +
        labs(x = var_labs[[x_var]],
             y = var_labs[[y_var]],
             fill = "CWM <-> Env. Slope",
             subtitle = paste0("Avg. R² over values of ",
                               paste(not_used_vars, collapse = " and "))) +
        theme(legend.position = "top",
          legend.text = element_text(angle = 45))
}

# Plotting CWM <-> Env. Slope
plot_k_A_slope = plot_average_slope(var_ba_slope, "k", "A") +
    scale_y_log10()

plot_A_BA_slope = plot_average_slope(var_ba_slope, "A", "B_over_A") +
    scale_x_log10() +
    scale_y_log10()

plot_k_BA_slope = plot_average_slope(var_ba_slope, "k", "B_over_A") +
    scale_y_log10()

plot_k_Hk_slope = plot_average_slope(var_ba_slope, "k", "H_over_k")

plot_A_Hk_slope = plot_average_slope(var_ba_slope, "A", "H_over_k") +
    scale_x_log10()

plot_BA_Hk_slope = plot_average_slope(var_ba_slope, "B_over_A", "H_over_k") +
    scale_x_log10()

slope_grid = plot_grid(plot_k_A_slope,
          plot_k_Hk_slope,
          plot_A_BA_slope,
          plot_A_Hk_slope,
          plot_k_BA_slope,
          plot_BA_Hk_slope,
          nrow = 3)

slope_grid
```


```{r cwm_env_param}
var_ba_df %>%
    filter(k %in% c(1.125, 1.5), H_over_k %in% c(0, 1, 2), A <= 1e-3, A >= 1e-5, B_over_A >= 10, B_over_A <= 1e4) %>%
    ggplot(aes(patch_optim, trait2_cwm, color = as.factor(B_over_A))) +
    geom_abline(slope = 1, intercept = 0, linetype = 2) +
    geom_line() +
    facet_grid(vars(A), vars(k, H_over_k), labeller = label_context) +
    labs(x = "Environment",
         y = "Trait 2 CWM")
```

## Considering all scenarios to explore

If we want to be exhaustive in terms of scenario we can use the following:

```{r all_scenars}
# Simulation parameters = median parameters
fixed_A = 1e-4
fixed_k = 1.25
fixed_B_over_A = 100
fixed_H_over_k = 1

# Generate all scenarios
weights = round(seq(0, 100, length.out = 3), digits = 0)

scenar_df = expand.grid(R = weights, A = weights, H = weights) %>%
    as_data_frame() %>%
    mutate(scenar_name   = paste0("R", R, "A", A, "H", H),
           trait_weights = purrr::pmap(list(R, A, H),
                                       ~create_trait_weights(..1, ..2, ..3)))
scenar_list = scenar_df$trait_weights
names(scenar_list) = scenar_df$scenar_name

# Actual simulation
plan(multiprocess, workers = 15)
tictoc::tic()

var_scenars = meta_simul_A_B_k_and_H(1,
                                     fixed_k,
                                     fixed_A,
                                     fixed_B_over_A,
                                     fixed_H_over_k,
                                     given_scenars = scenar_list) %>%
    map_dfr(as_tibble)

tictoc::toc()


var_scenars_df = var_scenars %>%
    mutate(patch1 = map(compo, function(x) {
        x["patches1",,] %>%
            as.data.frame() %>%
            rownames_to_column("species") %>%
            gather("timestep", "N", -species) %>%
            mutate(timestep = as.numeric(gsub("time", "", timestep)))
    }),
    patch13 = map(compo, function(x) {
        x["patches13",,] %>%
            as.data.frame() %>%
            rownames_to_column("species") %>%
            gather("timestep", "N", -species) %>%
            mutate(timestep = as.numeric(gsub("time", "", timestep)))
    }),
    patch25 = map(compo, function(x) {
        x["patches25",,] %>%
            as.data.frame() %>%
            rownames_to_column("species") %>%
            gather("timestep", "N", -species) %>%
            mutate(timestep = as.numeric(gsub("time", "", timestep)))
    }),
    R_scenar = as.numeric(gsub("R(\\d+)A\\d+H\\d+", "\\1", scenario, perl = TRUE)),
    A_scenar = as.numeric(gsub("R\\d+A(\\d+)H\\d+", "\\1", scenario, perl = TRUE)),
    H_scenar = as.numeric(gsub("R\\d+A\\d+H(\\d+)", "\\1", scenario, perl = TRUE)))
```


```{r scenar_patch_dynamics}
var_scenars_df %>%
    unnest(patch13) %>%
    filter(timestep <= 50) %>%
    ggplot(aes(timestep, N, color = species)) +
    geom_line() +
    facet_grid(vars(R_scenar), vars(A_scenar, H_scenar), labeller = label_context) +
    labs(subtitle = paste0("Patch 13 Dynamics – ",
                           "A: ", fixed_A,
                           " ; k: ", fixed_k,
                           " ; B_over_A: ", fixed_B_over_A,
                           " ; H_over_k: ", fixed_H_over_k)) +
    theme(legend.position = "none")
```

We want to see the trait value of species in function of environment colored by local abundances with a line representing the CWM in function of the environment. Facets are different scenarios

```{r trait_abund_scenarios}
set.seed(1)
used_traits = generate_cor_traits(n_patches, n_species, n_traits - 1,
                                  cor_coef = 0)

var_scenars_abund = var_scenars %>%
    mutate(time150 = map(compo, function(x) {
        x[,,"time150"] %>%
            as.data.frame() %>%
            rownames_to_column("patch") %>%
            gather("species", "N", -patch) %>%
            mutate(patch = as.numeric(gsub("patches", "", patch)))
    }),
    R_scenar = as.numeric(gsub("R(\\d+)A\\d+H\\d+", "\\1", scenario, perl = TRUE)),
    A_scenar = as.numeric(gsub("R\\d+A(\\d+)H\\d+", "\\1", scenario, perl = TRUE)),
    H_scenar = as.numeric(gsub("R\\d+A\\d+H(\\d+)", "\\1", scenario, perl = TRUE))) %>%
    unnest(time150) %>%
    inner_join(as.data.frame(used_traits) %>%
                   rownames_to_column("species"),
               by = "species")

var_scenars_cwm = var_scenars_abund %>%
    group_by(k, A, B_over_A, H_over_k, seed, compet_status, env, traits,
             scenario, R_scenar, A_scenar, H_scenar, patch) %>%
    summarise(cwm = weighted.mean(trait2, N))

ggplot(var_scenars_abund %>%
               filter(N > 0),
           aes(patch, trait2)) +
        stat_summary_2d(aes(z = N), geom = "raster", bins = 22,
                        interpolate = TRUE) +
        geom_line(data = var_scenars_cwm, aes(y = cwm, color = "firebrick"),
                  size = 1) +
        facet_grid(vars(R_scenar), vars(A_scenar, H_scenar),
                   labeller = label_context) +
        scale_fill_viridis_c(option = "E") +
        scale_color_manual(name = "CWM", values = c(firebrick = "grey80"),
                           labels = "") +
        labs(x = "Environment",
             y = "Trait Value",
             fill = "Species Abundance",
             subtitle = paste0("Patch 13 Dynamics – ",
                           "A: ", fixed_A,
                           " ; k: ", fixed_k,
                           " ; B_over_A: ", fixed_B_over_A,
                           " ; H_over_k: ", fixed_H_over_k)) +
        guides(colour = guide_legend(override.aes = list(size = 1,
                                                         color = "grey50"))) +
        theme(legend.position = "top")
```

### Higher Initial population

We want to test the effect of initial conditions on patch dynamics.

```{r init_cond_patch_dynamics}
composition[,, "time1"] <- 500

plan(multiprocess, workers = 15)
tictoc::tic()

higher_init_pop = meta_simul_A_B_k_and_H(1,
                                         fixed_k,
                                         fixed_A,
                                         fixed_B_over_A,
                                         fixed_H_over_k,
                                         given_scenars = scenar_list) %>%
    map_dfr(as_tibble)

tictoc::toc()

higher_init_pop_df = higher_init_pop %>%
    mutate(patch1 = map(compo, function(x) {
        x["patches1",,] %>%
            as.data.frame() %>%
            rownames_to_column("species") %>%
            gather("timestep", "N", -species) %>%
            mutate(timestep = as.numeric(gsub("time", "", timestep)))
    }),
    patch13 = map(compo, function(x) {
        x["patches13",,] %>%
            as.data.frame() %>%
            rownames_to_column("species") %>%
            gather("timestep", "N", -species) %>%
            mutate(timestep = as.numeric(gsub("time", "", timestep)))
    }),
    patch25 = map(compo, function(x) {
        x["patches25",,] %>%
            as.data.frame() %>%
            rownames_to_column("species") %>%
            gather("timestep", "N", -species) %>%
            mutate(timestep = as.numeric(gsub("time", "", timestep)))
    }),
    R_scenar = as.numeric(gsub("R(\\d+)A\\d+H\\d+", "\\1", scenario, perl = TRUE)),
    A_scenar = as.numeric(gsub("R\\d+A(\\d+)H\\d+", "\\1", scenario, perl = TRUE)),
    H_scenar = as.numeric(gsub("R\\d+A\\d+H(\\d+)", "\\1", scenario, perl = TRUE)))

higher_init_pop_df  %>%
    unnest(patch1) %>%
    ggplot(aes(timestep, N, color = species)) +
    geom_line() +
    facet_grid(vars(R_scenar), vars(A_scenar, H_scenar), labeller = label_context) +
    labs(subtitle = paste0("Patch 1 Dynamics – ",
                           "A: ", fixed_A,
                           " ; k: ", fixed_k,
                           " ; B_over_A: ", fixed_B_over_A,
                           " ; H_over_k: ", fixed_H_over_k)) +
    theme(legend.position = "none")
```


## The fitness, optimality and abundance triangle

Here we want to investigate the link between abundance, fitness and optimality.
Now that we've done it for a single site we can try to generalize the process for all sites.

```{r all_sites_optimality}
given_compo = var_a_var_k_var_ba[[325]][[1]]$compo[[1]]

all_sp_data = lapply(seq_len(nrow(given_compo)), function(site_index) {
    
    site_abund = given_compo[site_index,,]
    
    
    # Estimate maximum growth rate
    max_growth = apply(site_abund, 1, function(given_abund) {
        
        time_before_extinct = sum(given_abund > 0)
        
        growth_rate = NA
        
        if (time_before_extinct > 10) {
            given_time = 1:time_before_extinct
            
            growth_model = growthrates::fit_spline(given_time,
                                                   given_abund[given_time])
            
            growth_rate = growth_model@par["mumax"]
        }
    }) %>%
        enframe("species", "max_growth_rate")
    
    
    # Get optimality
    optim_dist = apply(used_traits, 1, function(given_traits) {
        weighted.mean(abs(site_index - given_traits), c(0.5, 0.5, 0, 0))
    }) %>%
        enframe("species", "distance_to_optimum")
    
    
    # Abundance
    sp_abund = site_abund[, 150] %>%
        enframe("species", "N150") %>%
        mutate(patch = site_index) %>%
        select(patch, everything())
    
    
    # Combine all data
    sp_abund %>%
        inner_join(optim_dist, by = "species") %>%
        inner_join(max_growth, by = "species")
}) %>%
    bind_rows()
```

```{r plot_patches, fig.width=7, fig.height=7}
plot_ab_growth_dist = all_sp_data %>%
    ggplot(aes(N150, max_growth_rate, color = distance_to_optimum)) +
    geom_point() +
    geom_smooth(method = "lm", se = FALSE) +
    ggpmisc::stat_poly_eq(formula = y ~ x, parse = TRUE) +
    ylim(NA, 1) +
    facet_wrap(~patch, labeller = label_both) +
    scale_color_viridis_c(option = "C") +
    labs(x     = "Abundance at time = 150",
         y     = "Maximum Growth Rate",
         color = "Distance to Optimum") +
    theme(legend.position = "top")
plot_ab_growth_dist


plot_ab_dist_growth = all_sp_data %>%
    ggplot(aes(N150, distance_to_optimum, color = max_growth_rate)) +
    geom_point() +
    geom_smooth(method = "lm", se = FALSE) +
    ggpmisc::stat_poly_eq(formula = y ~ x, parse = TRUE,
                          label.x.npc = "right") +
    facet_wrap(~patch, labeller = label_both) +
    scale_color_viridis_c(option = "C", limits = c(NA, 1)) +
    labs(x     = "Abundance at time = 150",
         y     = "Distance to Optimum",
         color = "Maximum Growth Rate") +
    theme(legend.position = "top")
plot_ab_dist_growth



plot_growth_dist_ab = all_sp_data %>%
    ggplot(aes(max_growth_rate, distance_to_optimum, color = N150)) +
    geom_point() +
    geom_smooth(method = "lm", se = FALSE) +
    ggpmisc::stat_poly_eq(formula = y ~ x, parse = TRUE,
                          label.x.npc = "right") +
    xlim(NA, 1) +
    facet_wrap(~patch, labeller = label_both) +
    scale_color_viridis_c(option = "C") +
    labs(x     = "Maximum Growth Rate",
         y     = "Distance to Optimum",
         color = "Abundance at time = 150") +
    theme(legend.position = "top")
plot_growth_dist_ab
```

### Showing the evolution of realized growth rates across patches

From a single simulation we can compute the realized growth rate. Then we can compare it across patches to see if certain patches exhibit specific dynamics.

```{r realized_growth_rate}
# Compute realized growth rates
real_gr = plyr::aaply(var_a_var_k_var_ba[[325]][[1]]$compo[[1]], 1,
                      function(species_time) {
    
  real_gr = (species_time[,-1] - species_time[, -ncol(species_time)]) /
               species_time[,-ncol(species_time)]
  
  return(real_gr)
})

real_gr_df = as.data.frame.table(real_gr) %>%
    rename(patch = X1, species = Var2, time = Var3, growth_rate = Freq) %>%
    mutate(time = as.numeric(gsub("time", "", time)))

plot_realized_growth_rate = ggplot(real_gr_df, aes(time, growth_rate,
                                                   color = species)) +
    geom_line() +
    facet_wrap(~patch) +
    labs(x = "Time", y = "Realized Growth Rate")
plot_realized_growth_rate
```


### Exploring the triangle across various trait scenarios (r = 0, r = -0.7, r = 0.7)

We want to explore the relationship between fitness, optimality and local abundance in function of trait scenarios (as well as different contributions)

```{r optimality_different_trait_corr}
# Simulation parameters
fixed_A = 1e-6
mean_k = 1.5
var_k  = 0.3
fixed_B_over_A = 100
fixed_H = 1

# Matrix of species maximum growth rates
set.seed(20190129)
k_matrix = matrix(rnorm(n_species, mean_k, var_k))
rownames(k_matrix) = paste0("species", seq(n_species))
colnames(k_matrix) = "k"

# Generate trait list
set.seed(1)
trait_list = list(
    uncor   = generate_cor_traits(n_patches, n_species, n_traits - 1,
                                  cor_coef = 0),
    negcor  = generate_cor_traits(n_patches, n_species, n_traits - 1,
                                  cor_coef = -0.7),
    highcor = generate_cor_traits(n_patches, n_species, n_traits - 1,
                                  cor_coef = 0.7)
)


# Actual simulation
tictoc::tic()
multi_traits_fixed = list(seed     = seq(1),
                          k        = list(k_matrix, k),
                          A        = fixed_A,
                          B_over_A = fixed_B_over_A,
                          H        = fixed_H) %>%
    cross() %>%
    future_map(function(x){
        meta_simul_A_B_k_and_H(
            seed_number    = x$seed,
            given_k        = x$k,
            given_A        = x$A,
            given_B_over_A = x$B_over_A,
            given_H        = x$H,
            given_traits   = trait_list)
    }) %>%
    set_names(nm = c("gaussian", "fixed"))
tictoc::toc()

multi_traits_triangle = map_dfr(multi_traits_fixed, function(simul_given_k) {
    map2(simul_given_k, trait_list,
         function(simul, trait_df) {
             
             given_compo = simul$compo[[1]]
             
             th_growth_rate = simul$rmatrix %>%
                 as_tibble() %>%
                 rownames_to_column("patch") %>%
                 mutate(patch = as.numeric(patch)) %>%
                 gather("species", "th_growth_rate", -patch)
             
             env_growth_rate = simul$rmatenv %>%
                 as_tibble() %>%
                 rownames_to_column("patch") %>%
                 mutate(patch = as.numeric(patch)) %>%
                 gather("species", "env_growth_rate", -patch)
             
             lapply(seq_len(nrow(given_compo)), function(site_index) {
                 
                 site_abund = given_compo[site_index,,]
                 
                 # Estimate maximum growth rate
                 max_growth = apply(site_abund, 1, function(given_abund) {
                     
                     # Get first moment where species goes extinct
                     time_before_extinct = which(given_abund == 0)[1] - 1
                     
                     # When species doesn't go extinct consider maximum time
                     if (is.na(time_before_extinct)) {
                         time_before_extinct = length(given_abund)
                     }
                     
                     growth_rate = NA_real_
                     
                     if (time_before_extinct > 10) {
                         given_time = 1:time_before_extinct
                         
                         growth_model = growthrates::fit_spline(given_time,
                                                                given_abund[given_time])
                         
                         growth_rate = growth_model@par[["mumax"]]
                     }
                     
                     ifelse(is.null(growth_rate), NA_real_, growth_rate)
                 }) %>%
                     enframe("species", "max_growth_rate")
                 
                 # Get optimality
                 optim_dist = apply(trait_df, 1, function(given_traits) {
                     weighted.mean(abs(site_index - given_traits), c(0.5, 0.5, 0, 0))
                 }) %>%
                     enframe("species", "distance_to_optimum")
                 
                 
                 # Abundance
                 sp_abund = site_abund[, 150] %>%
                     enframe("species", "N150") %>%
                     mutate(patch = site_index) %>%
                     select(patch, everything())
                 
                 
                 # Combine all data
                 sp_abund %>%
                     inner_join(optim_dist, by = "species") %>%
                     inner_join(max_growth, by = "species")
             }) %>%
                 bind_rows() %>%
                 inner_join(th_growth_rate, by = c("patch", "species")) %>%
                 inner_join(env_growth_rate, by = c("patch", "species"))
         }) %>%
        set_names(nm = names(trait_list)) %>%
        bind_rows(.id = "trait_cor") },
    .id = "k_type")
```

```{r plot_optimality_diff_trait_cor, fig.height=9.5}
fig_double_facet = function(given_df, x_var, y_var, col_var, given_labs,
                            given_label_pos = "left", trans_col = "identity") {
    given_df %>%
        filter(patch %in% seq(1, 25, by = 6)) %>%
    ggplot(aes_string(x_var, y_var, color = col_var)) +
        geom_hline(yintercept = 0, linetype = 2) +
        geom_point() +
        geom_smooth(method = "lm", se = FALSE) +
        ggpmisc::stat_poly_eq(formula = y ~ x, parse = TRUE,
                              aes(label = paste(..eq.label.., ..rr.label..,
                                            sep = "~~~")),
                              label.x.npc = given_label_pos, size = 3) +
        facet_grid(vars(patch), vars(k_type, trait_cor),
                   labeller = labeller(patch = label_both)) +
        labs(x     = given_labs[[x_var]],
             y     = given_labs[[y_var]],
             color = given_labs[[col_var]]) +
        scale_color_viridis_c(option = "C", trans = trans_col) +
        theme(legend.position = "top",
              strip.text = element_text(size = 8, margin = margin(1, 1, 1, 1)))
}

triangle_labs = c(N150                = "Abundance at time = 150",
                  max_growth_rate     = "Maximum Growth Rate",
                  distance_to_optimum = "Distance to Optimum")

plot_multi_ab_growth_dist = fig_double_facet(
    multi_traits_triangle, "N150", "max_growth_rate", "distance_to_optimum",
    triangle_labs) +
    scale_y_sqrt()
plot_multi_ab_growth_dist

plot_multi_ab_dist_growth = fig_double_facet(
    multi_traits_triangle, "N150", "distance_to_optimum", "max_growth_rate",
    triangle_labs, "right")
plot_multi_ab_dist_growth

plot_multi_growth_dist_ab = fig_double_facet(
    multi_traits_triangle, "max_growth_rate", "distance_to_optimum", "N150",
    triangle_labs, "right") +
    scale_x_sqrt()
plot_multi_growth_dist_ab
```

```{r growth_and_other_performance_indinces}
multi_traits_triangle %>%
    gather("growth_rate_type", "growth_rate_value", contains("growth_rate")) %>%
    filter(patch %in% seq(1, 25, by = 6), growth_rate_value < 4, trait_cor == "uncor") %>%
    mutate(growth_rate_type = as_factor(growth_rate_type)) %>%
    gather("perf_type", "perf_value", N150, distance_to_optimum) %>%
    ggplot(aes(perf_value, growth_rate_value, color = growth_rate_type)) +
    geom_point(alpha = 1/6) +
    geom_smooth(method = "lm", se = FALSE) +
    ggpmisc::stat_poly_eq(formula = y ~ x, parse = TRUE, label.x.npc = "left",
                          aes(label = ..rr.label..), size = 3) +
    facet_grid(vars(k_type), vars(perf_type), scales = "free_x",
               labeller = labeller(perf_type = c(N150 = "Abundance at t = 150",
                                                 distance_to_optimum = "Distance to Environment Optimum"),
                                   k_type = c(fixed    = "k = 1.5",
                                              gaussian = "k ~> N(1.5, 0.3)"))) +
    scale_color_brewer(labels = c(env_growth_rate = "Environmental Growth Rate\n (Growth only)",
                                  max_growth_rate = "Realized Growth Rate",
                                  th_growth_rate  = "Theoretical Growth Rate\n(Growth + Hierarch. Compet.)"),
                       palette = "Dark2") +
    labs(x = "Performance Value", y = "Growth Rate", color = NULL,
         subtitle = "Growth Estimates vs. other Performance Indices – All patches",
         caption = paste0("No trait correlation; ",
                          "A = ", fixed_A,
                          "; B/A = ", fixed_B_over_A,
                          "; H = ", fixed_H)) +
    theme(legend.position = "top",
          panel.grid = element_blank())
```
