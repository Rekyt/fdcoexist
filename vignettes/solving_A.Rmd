---
title: "Exploring to find the good A value"
author:
    - Pierre Denelle, Matthias Grenié, Cyrille Violle, François Munoz and Caroline M. Tucker
date: "`r format(Sys.time(), '%d %B %Y')`"
output: pdf_document
vignette: >
  %\VignetteIndexEntry{Full equation of the model}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
header-includes:
    - \usepackage{cancel}
    - \usepackage{mathtools}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)


library("cowplot")
library("tidyr")
library("dplyr")
library("ggplot2")
library("stringr")
library("tibble")
library("furrr")

# Functions --------------------------------------------------------------------
compute_moments = function(simulation_routine, trait_df = traits) {
    # CWM computation
    ab_rel = (simulation_routine$compo[,,150] /
                  rowSums(simulation_routine$compo[,,150]))
    cwm_df = ab_rel %*% trait_df
    # Values stored in moments_df
    moments_df = as.data.frame(cwm_df)
    colnames(moments_df) = "cwm"
    moments_df = tibble::rownames_to_column(moments_df, "patch")
    moments_df$env = seq(patches)
    # Add CWV
    cwv_df = (ab_rel %*% trait_df^2) - cwm_df^2
    cwv_df = as.data.frame(cwv_df)
    colnames(cwv_df) = "cwv"
    cwv_df = tibble::rownames_to_column(cwv_df, "patch")
    moments_df = dplyr::left_join(moments_df, cwv_df, by = "patch")
    
    return(moments_df)
}

# Compute a data.frame of number of individuals in function of optimal trait
# for competition and growth
landscape_df = function(multiple_traits_scenario, trait_df, trait_weights,
                        time = n_gen) {
    
    growth_traits = subset(trait_weights, growth_weight != 0)$trait
    compet_traits = subset(trait_weights, compet_weight != 0)$trait
    
    
    population_df = multiple_traits_scenario$compo[,,time] %>%
        as.data.frame() %>%
        rownames_to_column("patch") %>%  # Add patch names as column
        # Transform to tidy data.frame (define name of columns and column name
        # for values)
        gather("species", "N", -patch)
    
    growth_df = enframe(rowMeans(trait_df[, growth_traits, drop = FALSE]),
                        "species", "growth_trait")
    
    compet_df = enframe(abs(rowMeans(trait_df[, compet_traits, drop = FALSE]) -
                                12.5), "species", "compet_dist")
    
    population_df %>%
        inner_join(growth_df, by = "species") %>%
        inner_join(compet_df, by = "species") %>%
        # Add patch number as a new column and compute distance to optimal value
        mutate(patch_optim = gsub("patches", "", patch) %>%
                   as.numeric(),
               optim_dist = abs(growth_trait - patch_optim))
}

# This function tidy a list of simulation routine to a single data.frame
# suitable to make figures.
tidy_simulation_list = function(simulation_list, set_of_traits, trait_scenarios,
                                time = n_gen, scenar_names = names(trait_scenarios)) {
    simulation_list %>%
        names() %>%
        # Tidy single simulations
        lapply(tidy_simulation,
               given_simul = simulation_list,
               given_traits = set_of_traits,
               given_trait_scenar = trait_scenarios,
               time = time) %>%
        # Re-add names
        set_names(nm = names(simulation_list)) %>%
        # Join into single data.frame
        bind_rows(.id = "scenario") %>%
        # Compute pre-CWMs
        mutate_at(vars(contains("trait")), funs(cwm = rel_abund * .)) %>%
        mutate(scenario = fct_relevel(scenario, scenar_names))
}

tidy_simulation = function(scenario, given_simul, given_traits,
                           given_trait_scenar, time = n_gen) {
    landscape_df(given_simul[[scenario]], given_traits,
                 trait_scenarios[[scenario]], time = time) %>%
        inner_join(given_traits %>%
                       as.data.frame() %>%
                       rownames_to_column("species"),
                   by = "species") %>%
        group_by(patch) %>%
        mutate(rel_abund = N/sum(N)) %>%
        ungroup()
}
# Initial parameters -----------------------------------------------------------
suppressMessages(devtools::load_all())

n_patches <- 25   # Number of patches
n_species <- 50   # Number of species
n_gen     <- 500  # Length of model run (generations)
initpop   <- 50   # initial population size
n_traits  <- 1    # number of traits
k         <- 1.15 # Maximum growth rate
env_width <- seq(10, 10, length.out = n_patches)  # Envtal filter strength
var_width <- seq(10, 1, length.out = n_patches) # Varying envtal filter strength

# Competition + Dispersion coefficients
B = 2e-4 # Scalar for intraspecific competition
A = B	# Alpha scalar
d = 0.05 # Dispersal percentage

# Generate environment
env <- seq(n_patches)

# Array for simulations
composition <- array(NA, dim = c(n_patches, n_species, n_gen),
                     dimnames = list(paste0("patches", seq(n_patches)),
                                     paste0("species", seq(n_species)),
                                     paste0("time", seq(n_gen))))
names(env) <- dimnames(composition)[[1]]

composition[,, "time1"] <- initpop

# Scenarios on traits affecting growth and competition
single_scenar = data.frame(trait            = "trait1",
                           growth_weight    = 1,
                           compet_weight    = 1,
                           hierarchy_weight = 1)

# Generate traits --------------------------------------------------------------
trait_df = data.frame(trait1 = rep(1, n_species))

rownames(trait_df) = paste0("species", seq(n_species))

# Graphical parameters ---------------------------------------------------------
theme_set(theme_bw(12) +
              theme(axis.text.x = element_text(angle = 45),
                    legend.text = element_text(angle = 45)))
```

# Analytical derivation of A value

We start from this equation
$$
N_{t+1, i, x} = \frac{
k \times \exp\left(- \displaystyle\frac{(\text{trait}_i - \text{env}_x)^2}{2\times \text{width}^2}\right) \times N_{t, i, x}}{
1 + A \times \displaystyle\sum_{j = 1,~j \neq i}^{S} N_{t, j, x}  (1 - \delta_{ij}) +
B \times N_{t,i,x}
}
$$
to get realistic value for $A$ and $B$.
We solve $N_{t+1, i, x} = N_{t, i, x}$ with $A = B$ and $1 - \delta_{ij} = 1$ for all $i$ and $j$ and for $\text{trait}_i - \text{env}_x = 0$.
We thus get:


\begin{equation}
    \begin{aligned}
    N_{t+1, i, x} =& N_{t, i, x}\\
    \Leftrightarrow N_{t, i, x} =& \frac{
        k  \times N_{t, i, x}}{
        1 + A \times \displaystyle\sum_{j = 1,~j \neq i}^{S} N_{t, j, x} +
        A \times N_{t,i,x}}\\
    \Leftrightarrow  N_{t, i, x} =& \frac{
        k  \times N_{t, i, x}}{
        1 + A \times \displaystyle\sum_{j = 1}^{S} N_{t, j, x}}\\
    \Leftrightarrow  \bcancel{N_{t, i, x}} =& \frac{
        k  \times \bcancel{N_{t, i, x}}}{
        1 + A \times \displaystyle\sum_{j = 1}^{S} N_{t, j, x}}\\
    \Leftrightarrow  1 =& \frac{k}{
        1 + A \times \displaystyle\sum_{j = 1}^{S} N_{t, j, x}}\\
    \Leftrightarrow  1 + A \times \displaystyle\sum_{j = 1}^{S} N_{t, j, x} &= k\\
    \Leftrightarrow  \Aboxed{A =& \frac{k - 1}{
        \displaystyle\sum_{j = 1}^{S} N_{t, j, x}}}
    \end{aligned}
\end{equation}

We can find a value for A heuristically computing it at the last generation for a number of sites.


# Heuristic value of A

Another way of choosing the A-value is to simulate the growth of 100 species with exactly the same traits and to see when the growth is canceled, with a number of maximal growth parameters.

```{r heuristical_A, fig.width=8.5, fig.height=8, echo = FALSE, warning=FALSE}
k_list = seq(1.05, 2, length.out = 9)
A_list = 2*10^-(seq(6))

fixing_A = cross(list(k = k_list, A = A_list)) %>%
    map(~multigen(traits = as.matrix(trait_df),
                  trait_weights = single_scenar,
                  env = env,
                  time = n_gen,
                  species = n_species,
                  patches = n_patches,
                  composition = composition,
                  A = .x$A, B = 2e-4, d = d,
                  k = .x$k, width = env_width))

all_k = map2(.x = fixing_A,
             .y = cross(list(k = k_list, A = A_list)),
            ~.x$compo[1,1,] %>%
                 enframe("time", "N") %>%
                 mutate(species = "species1",
                        time = gsub("time", "", time) %>%
                            as.numeric(),
                        k = .y$k,
                        A = .y$A)) %>%
    bind_rows() %>%
    select(A, k, species, everything())


plot_all_k = ggplot(all_k, aes(time, N)) +
    geom_line(color = "darkred") +
    facet_grid(vars(A),
               vars(k),
               labeller = labeller(k = function(x) x %>%
                                       as.numeric() %>%
                                       round(2) %>%
                                       paste0("k = ", .),
                                   A = function(x) x %>%
                                       as.numeric() %>%
                                       paste0("A = ", .))) +
    scale_y_log10() +
    labs(subtitle = paste0("B = ", 2e-4, "; ", "d = ", d, "; ",
                           "N sp. = ", n_species),
         y = "Number of individuals")

plot_all_k
```

