---
title: "fdcoexist equation only"
author:
    - Pierre Denelle, Matthias Grenié, Cyrille Violle, François Munoz and Caroline M. Tucker
date: "`r format(Sys.time(), '%d %B %Y')`"
output: pdf_document
vignette: >
  %\VignetteIndexEntry{Full equation of the model}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
---
title: "fdcoexist"
author:
    - Pierre Denelle, Matthias Grenié, Cyrille Violle and Caroline M. Tucker
date: "`r format(Sys.time(), '%d %B %Y')`"
output: pdf_document
editor_options: 
  chunk_output_type: console
---

```{r setup, echo=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE,
                      error = TRUE,
                      fig.width = 8, fig.height = 10.5)

# Packages ---------------------------------------------------------------------
suppressPackageStartupMessages({
    suppressWarnings({
        library("cowplot")
        library("tidyverse")
        library("directlabels")
    })
})
# Functions --------------------------------------------------------------------
compute_moments = function(simulation_routine, trait_df = traits) {
    # CWM computation
    ab_rel = (simulation_routine$compo[,,150] /
                  rowSums(simulation_routine$compo[,,150]))
    cwm_df = ab_rel %*% trait_df
    # Values stored in moments_df
    moments_df = as.data.frame(cwm_df)
    colnames(moments_df) = "cwm"
    moments_df = tibble::rownames_to_column(moments_df, "patch")
    moments_df$env = seq(patches)
    # Add CWV
    cwv_df = (ab_rel %*% trait_df^2) - cwm_df^2
    cwv_df = as.data.frame(cwv_df)
    colnames(cwv_df) = "cwv"
    cwv_df = tibble::rownames_to_column(cwv_df, "patch")
    moments_df = dplyr::left_join(moments_df, cwv_df, by = "patch")
    
    return(moments_df)
}

# Compute a data.frame of number of individuals in function of optimal trait
# for competition and growth
landscape_df = function(multiple_traits_scenario, trait_df, trait_weights,
                        time = n_gen) {
    
    growth_traits = subset(trait_weights, growth_weight != 0)$trait
    compet_traits = subset(trait_weights, compet_weight != 0)$trait
    
    
    population_df = multiple_traits_scenario$compo[,,time] %>%
        as.data.frame() %>%
        rownames_to_column("patch") %>%  # Add patch names as column
        # Transform to tidy data.frame (define name of columns and column name
        # for values)
        gather("species", "N", -patch)
    
    growth_df = enframe(rowMeans(trait_df[, growth_traits, drop = FALSE]),
                        "species", "growth_trait")
    
    compet_df = enframe(abs(rowMeans(trait_df[, compet_traits, drop = FALSE]) -
                                12.5), "species", "compet_dist")
    
    population_df %>%
        inner_join(growth_df, by = "species") %>%
        inner_join(compet_df, by = "species") %>%
        # Add patch number as a new column and compute distance to optimal value
        mutate(patch_optim = gsub("patches", "", patch) %>%
                   as.numeric(),
               optim_dist = abs(growth_trait - patch_optim))
}

# This function tidy a list of simulation routine to a single data.frame
# suitable to make figures.
tidy_simulation_list = function(simulation_list, set_of_traits, trait_scenarios,
                                time = n_gen, scenar_names = names(trait_scenarios)) {
    simulation_list %>%
        names() %>%
        # Tidy single simulations
        lapply(tidy_simulation,
               given_simul = simulation_list,
               given_traits = set_of_traits,
               given_trait_scenar = trait_scenarios,
               time = time) %>%
        # Re-add names
        set_names(nm = names(simulation_list)) %>%
        # Join into single data.frame
        bind_rows(.id = "scenario") %>%
        # Compute pre-CWMs
        mutate_at(vars(contains("trait")), funs(cwm = rel_abund * .)) %>%
        mutate(scenario = fct_relevel(scenario, scenar_names))
}

tidy_simulation = function(scenario, given_simul, given_traits,
                           given_trait_scenar, time = n_gen) {
    landscape_df(given_simul[[scenario]], given_traits,
                 trait_scenarios[[scenario]], time = time) %>%
        inner_join(given_traits %>%
                       as.data.frame() %>%
                       rownames_to_column("species"),
                   by = "species") %>%
        group_by(patch) %>%
        mutate(rel_abund = N/sum(N)) %>%
        ungroup()
}
# Initial parameters -----------------------------------------------------------
suppressMessages(devtools::load_all())

n_patches <- 25   # Number of patches
n_species <- 100  # Number of species
n_gen     <- 150  # Length of model run (generations)
initpop   <- 50   # initial population size
n_traits  <- 3    # number of traits
k         <- 1.2  # Maximum growth rate
env_width <- seq(10, 10, length.out = n_patches)  # Envtal filter strength
var_width <- seq(10, 1, length.out = n_patches) # Varying envtal filter strength

# Competition + Dispersion coefficients
B = 1e-3 # Scalar for intraspecific competition
A = 1e-5 # Alpha scalar
d = 0.0 # Dispersal percentage

# Hierarchical coefficients
H = 0.6
th_max = 25

# Generate environment
env <- seq(n_patches)

# Array for simulations
composition <- array(NA, dim = c(n_patches, n_species, n_gen),
                     dimnames = list(paste0("patches", seq(n_patches)),
                                     paste0("species", seq(n_species)),
                                     paste0("time", seq(n_gen))))
names(env) <- dimnames(composition)[[1]]

composition[,, "time1"] <- initpop

# Define scenarios -------------------------------------------------------------
# Scenarios on traits affecting growth and competition
trait_scenarios = list(
    R0A0 = data.frame(trait = paste0("trait", 1:3),
                      growth_weight = c(1, 0, 0),
                      compet_weight = c(0, 0, 1)),
    R0A100 = data.frame(trait = paste0("trait", 1:3),
                        growth_weight = c(1, 0, 0),
                        compet_weight = c(0, 1, 0)),
    R10A90   = data.frame(trait = paste0("trait", 1:3),
                          growth_weight = c(0.90, 0.10, 0),
                          compet_weight = c(0,    0.90, 0.10)),
    R25A75   = data.frame(trait = paste0("trait", 1:3),
                          growth_weight = c(0.75, 0.25, 0),
                          compet_weight = c(0,    0.75, 0.25)),
    R50A50   = data.frame(trait = paste0("trait", 1:3),
                          growth_weight = c(0.5, 0.5, 0),
                          compet_weight = c(0,   0.5, 0.5)),
    R75A25   = data.frame(trait = paste0("trait", 1:3),
                          growth_weight = c(0.25, 0.75, 0),
                          compet_weight = c(0,    0.25, 0.75)),
    R90A10   = data.frame(trait = paste0("trait", 1:3),
                          growth_weight = c(0.10, 0.90, 0),
                          compet_weight = c(0,    0.10, 0.90)),
    R100A0   = data.frame(trait = paste0("trait", 1:3),
                          growth_weight = c(0, 1, 0),
                          compet_weight = c(0, 0, 1)),
    R100A100 = data.frame(trait = paste0("trait", 1:3),
                          growth_weight = c(0, 1, 0),
                          compet_weight = c(0, 1, 0))
)

# Generate traits --------------------------------------------------------------
trait_seed = 5
# Make traits with different correlations
set.seed(trait_seed)
uncor_traits = generate_cor_traits(n_patches, n_species, n_traits - 1,
                                   cor_coef = 0)
set.seed(trait_seed)
low_cor_traits = generate_cor_traits(n_patches, n_species, n_traits - 1,
                                     cor_coef = 0.3)

set.seed(trait_seed)
high_cor_traits = generate_cor_traits(n_patches, n_species, n_traits - 1,
                                      cor_coef = 0.7)

# Graphical parameters ---------------------------------------------------------
theme_set(theme_bw(12) +
              theme(axis.text.x = element_text(angle = 45),
                    legend.text = element_text(angle = 45)))

# Graphical functions ----------------------------------------------------------
label_scenar_facets = function(scenar_name) {
    scenar_name %>%
        as.character() %>%
        str_remove("R") %>%
        str_split("A") %>%
        map_chr(~paste0("Growth = ",  .x[1], "%\n",
                        "Compet. = ", .x[2], "%"))
}

facet_scenar = facet_wrap(vars(scenario),
                          labeller = labeller(scenario = label_scenar_facets))

label_compet_env = labeller(compet_status = c(compet = "Competition",
                                              no_compet = "Only intra comp."),
                            env_width     = c(constant = "Constant\nEnv. Filter Strength",
                                              varying  = "Varying\nEnv. Filter Strength"))

# Plot the relationship between species abundances along the environment in the
# different scenarios
fig_abund_env = function(simul_df, simul_label) {
    ggplot(simul_df %>%
               filter(N >= 2), aes(patch_optim, N)) +
        geom_point(shape = ".") +
        geom_smooth() +
        facet_scenar +
        labs(x = "Environmental value",
             y = "Species Abundance (gen. = 150)",
             subtitle = simul_label)
}

# Plot the relationship between the CWM of the different trait along the
# environment for the different scenarios
fig_cwm_env = function(simul_df, simul_label) {
    simul_df %>%
        filter(N >= 2) %>%
        group_by(scenario, patch) %>%
        summarise_at(vars(contains("cwm")), sum, na.rm = TRUE) %>%
        mutate(patch_optim = gsub("patches", "", patch) %>%
                   as.numeric()) %>%
        gather("cwm_name", "cwm_value", contains("cwm")) %>%
        ggplot(aes(patch_optim, cwm_value, color = cwm_name)) +
        geom_point() +
        geom_smooth() +
        facet_scenar +
        scale_color_discrete(labels = c(trait1_cwm = "Trait 1",
                                        trait2_cwm = "Trait 2",
                                        trait3_cwm = "Trait 3")) +
        labs(x = "Environment",
             y = "Community-Weighted Mean (CWM)",
             color = NULL,
             subtitle = simul_label) +
        theme(legend.position = "top")
}

# Plot the relationship between patch CWMs along the environment considering
# total abundance
fig_cwm_env_abund = function(simul_df, simul_label, n_bins = 24,
                             given_trans = "identity") {
    simul_df %>%
        group_by(scenario, patch) %>%
        summarise_at(vars(contains("cwm"), N), sum) %>%
        mutate(patch_optim = gsub("patches", "", patch) %>%
                   as.numeric()) %>%
        gather("cwm_name", "cwm_value", contains("cwm")) %>%
        ungroup() %>%
        ggplot(aes(patch_optim, cwm_value, z = N)) +
        stat_summary_2d(bins = n_bins) +
        facet_grid(vars(scenario), vars(cwm_name),
                   labeller = labeller(scenario = label_scenar_facets,
                                       cwm_name = label_value)) +
        scale_fill_viridis_c(trans = given_trans, option = "E") +
        labs(x = "Environment",
             y = "Community-Weighted Mean (CWM)",
             fill = "Total Abundance",
             subtitle = simul_label) +
        theme(legend.position = "top")
}

# Relationship betwee, species trait values along the enviroment showing their
# local abundances for the different traits considered
fig_ind_landscape = function(simul_df, simul_label, n_bins = 22,
                             given_trans = "identity") {
    
    simul_df <- simul_df %>%
        select(-contains("cwm")) %>%
        gather("trait_name", "trait_value", contains("trait"))
    
    simul_df_cwm <- simul_df %>%
        group_by(scenario, patch, trait_name) %>%
        summarise(cwm = weighted.mean(trait_value, N))
    
    simul_df2 <- left_join(simul_df, simul_df_cwm,
                           by = c("scenario", "patch", "trait_name"))
    
    ggplot(simul_df2 %>%
               filter(N > 0),
           aes(patch_optim, trait_value, z = N)) +
        stat_summary_2d(geom = "raster", bins = n_bins, interpolate = TRUE) +
        geom_line(aes(patch_optim, cwm, color = "firebrick"), size = 1) +
        facet_grid(vars(scenario), vars(trait_name),
                   labeller = labeller(scenario = label_scenar_facets,
                                       trait_name = function(x) gsub("_", " ",
                                                                     x))) +
        scale_fill_viridis_c(trans = given_trans, option = "E") +
        scale_color_manual(name = "CWM", values = c(firebrick = "grey80"),
                           labels = "") +
        labs(x = "Environment",
             y = "Trait Value",
             fill = "Species Abundance",
             subtitle = simul_label) +
        guides(colour = guide_legend(override.aes = list(size = 1,
                                                         color = "grey50"))) +
        theme(legend.position = "top")
}
```

This document presents the relationships between functional traits of species and an environmental gradient.

Our coexistence model is developed following this equation:

\begin{equation}
N_{t+1, i, x} = \frac{R_{i, x} \times N_{t, i, x}}{1 + A \times \alpha_i}
\end{equation}

with

\begin{gather}
\alpha_i = \sum_{j = 1, j \neq i}^{S} N_{t, j, x} \times (1 - \delta_{ij})\\
R_{i, x} = k \times \exp\left(- \frac{(\text{trait}_i - \text{env}_x)^2}{2\times \text{width}^2}\right)
\end{gather}

If we replace $\alpha_i$ and $R_{i, x}$ in the first equation it gives:

\begin{equation}
N_{t+1, i, x} = \frac{
k \times \exp\left(- \displaystyle\frac{(\text{trait}_i - \text{env}_x)^2}{2\times \text{width}^2}\right) \times N_{t, i, x}}{
1 + A \times \displaystyle\sum_{j = 1, j \neq i}^{S} N_{t, j, x} \times (1 - \delta_{ij})
}
\end{equation}

The equation above only considers inter-specific competition when $j \neq i$ in the sum. We can however add intra-specific competition when $j = i$. Each site has a species-specific carrying capacity $K$ as the number of individuals approaches this carrying capacity the intra-specific competition increases:
\begin{equation}
\alpha_{ii} = B \times N_{t,i,x}
\end{equation}

Thus the equation becomes:

\begin{equation}
N_{t+1, i, x} = \frac{
k \times \exp\left(- \displaystyle\frac{(\text{trait}_i - \text{env}_x)^2}{2\times \text{width}^2}\right) \times N_{t, i, x}}{
1 + A \left( \displaystyle\sum_{j = 1,~j \neq i}^{S} N_{t, j, x}  (1 - \delta_{ij}) +
\frac{B}{A} \times N_{t,i,x} \right)
}
\end{equation}

with $A$ the coefficient scaling inter-specific competition and $B$ the one for intra-specific competition. 

Because several traits participate to the growth term depending on their contribution we can rewrite the growth term as:
\begin{equation}
R_{i, x} = \sum_{g = 1}^T w_g \times k \times \exp\left(- \frac{(\text{trait}_{g,i} - \text{env}_x)^2}{2\times \text{width}^2} \right)
\end{equation}

with $g$ the trait number, $0 \leq w_g \leq 1$ the contribution of this trait to growth (and $\sum_{g = 1}^T w_g = 1$), $\text{trait}_{g, i}$ the trait number $g$ of species $i$.

If we add hierarchical competition, the species with the largest trait has an increased growth. We can include this as a "bonus" term in the computation of the growth term $R_{i,x}$ such as:

\begin{gather}
R_{i, x} = R_{i, x, \text{env}} + R_{i, x, \text{hierarch.}}\\
R_{i, x, \text{hierarch.}} = \sum_{c = 1}^{T_c} w_c \times H \times \frac{t_i}{\text{max}(t_i)} \\
R_{i, x} = k \left[ \sum_{g = 1}^T w_g \times \exp\left(- \frac{(\text{trait}_{g,i} - \text{env}_x)^2}{2\times \text{width}^2} \right) + \frac{H}{k} \sum_{c = 1}^{T_c} w_c \frac{\text{trait}_i}{\text{max}(\text{trait}_i)} \right],
\end{gather}

with$w_g$ the weight of traits contributing to growth, $w_c$ the weight of traits contributing to competition (as many as $T_c$).

So the final equation looks like the following:

\begin{equation}
N_{t+1, i, x} = \frac{
    k \left[ \displaystyle\sum_{g = 1}^T w_g \times \exp\left(- \displaystyle\frac{(\text{trait}_{g,i} - \text{env}_x)^2}{2\times \text{width}^2} \right) + \frac{H}{k} \sum_{c = 1}^{T_c} w_c \frac{\text{trait}_i}{\text{max}(\text{trait}_i)} \right] \times N_{t, i, x}}{
1 + A \left( \displaystyle\sum_{j = 1,~j \neq i}^{S} N_{t, j, x}  (1 - \delta_{ij}) +
\frac{B}{A} \times N_{t,i,x} \right)
}
\end{equation}
